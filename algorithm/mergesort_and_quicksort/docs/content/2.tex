\subsection{归并排序mergesort}
\subsubsection{算法类别}
mergesort(归并排序)是一种基于\textbf{分治}的算法.

\subsubsection{算法思路}
在mergesort中, 待排序数组被分为两等分, 分别排序后合并为一个数组. \par
mergesort是一个递归算法, 持续的将数组二等分并对等分后得到的两个数组
分别进行mergesort, 直到数组不能再分, 此时数组为空或仅剩1个元素.
也就是说, 这是递归的终止情况. 如果数组有多个元素, 将数组分为两等份,
并在每一份上递归的调用mergesort. 最终, 当两半数组都被排序, 对两个数组
执行merge(合并)操作. \par
merge(合并)操作是将两个较小的有序数组结合成一个大的有序数组的过程.

\subsubsection{关键函数及代码段的描述}
采用non-recursive的迭代方式实现mergesort, 基于DRY \footnote{
	DRY: don't repeat yourself, 即不要做重复性的工作,
	通过良好的函数和类的抽象减少冗余和重复代码的出现}
的原则, 将mergesort分为三个函数, 分别是mergeSort(), mergePass(int *x,
int *y, int s, int n)和merge(int *c, int *d, int l, int m, int r). \par
mergeSort()是归并排序的入口函数, 管理步长倍增, 并通过将数组a和数组
b交替作为辅助数组的方式, 减少了一半的元素赋值操作. \par
mergePass()是归并排序中的一遍, 通过不断调用merge(),
将两个子序列用步长s按从小到大的顺序排序. \par
merge()函数将两个子数组c[l, ..., m]和c[m+1, ..., r]合并到d中.
\begin{lstlisting}[language=c++]
/**
 * Iterative mergesort function to sort a[0, ..., n-1], 
 * Merge subarrays in bottam up manner. First merge subarrays of
 * size 1 to create sorted subarrays of size 2, then merge subarrays
 * of size 2 to create sorted subarrays of size 4, and vice versa.
 */
void mergeSort() {
	// Initializing...
	int s = 1;
	while (s < n) {
		// treat b as assistant array
		mergePass(a, b, s, n);
		// double the step size
		s += s;
		// treat a as assistant array
		mergePass(b, a, s, n);
		// double the step size
		s += s;
	}
}

/**
 * A pass of merge with step size of s.
 */
void mergePass(int *x, int *y, int s, int n) {
	int i = 0; // left variable
	// merge until less than 2*s elements left.
	if (i + step_size - 1 < n) {
		// merge till the end of array
	} else {
		// append rest elements of x to y
	}
}

/**
 * Function to merge the two halves c[l, ..., m] and c[m+1, ..., r]
 * to d
 */
void merge(int *c, int *d, int l, int m, int r) {
	int i = l;
	int j = m+1;
	int k = i;
	// merge the two halves of array c to array d
	while(left half not reach the end &&
		right half of c not reach the end) {
			 append smaller element of c[i] and c[j] to d[k]
			 and increase i and k or j and k
		}

	// if left half of array c reaches the end, append rest elements
	// of right half of array c to d
	if (i > m) {
		append rest elements of right half of array c to d
	} else {
		vice versa
	}
}
\end{lstlisting}

\subsubsection{算法时间及空间复杂性分析}
\paragraph{空间复杂度分析}
mergesort需要一个长度为n的辅助数组进行辅助merge, 故空间复杂度为$O(n)$.

\paragraph{时间复杂度分析}
对于mergesort, 比较和挪动元素都发生在merge阶段, 由于对两个元素不进行
比较就不可能进行挪动, 估元素移动次数不会大于比较次数, 只需根据分析次数
即可分析时间复杂度. \par
由于归并排序是递归的过程, 可以方便地写出递推式:
\begin{align}
	\label{equ:recursive-equation}
	C(1)       & = 0                                \\
	C_{max}(n) & = 2C(\frac{n}{2}) + n-1            \\
	C_{min}(n) & = 2C(\frac{n}{2}) + \frac{n}{2}    \\
	C_{avg}(n) & = 2C(\frac{n}{2}) + \frac{3n-2}{2}
\end{align}
令\(n=2^k\), 将式\ref{equ:recursive-equation}中$O(n)$项
用$O(n)$代替, 则最好, 最坏和平均情形都为相同形式, 即
\begin{equation}
	C(n) = 2C(\frac{n}{n})+(n)
\end{equation}
记$C(n)$为比较次数, 有
\begin{gather}
	\label{equ:recursive_equation_derivation}
	C'(0) = 0            \\
	C'(k) = 2C'(k-1)+2^k
\end{gather}
得
\begin{equation}
	C'(k) = 2^kC'(0)+k\cdot 2^k = k\cdot 2^k
\end{equation}
即
\begin{equation}
	C(n) = n\log_2{n}
\end{equation}
综上, mergesort的时间复杂度为$O(n\log n)$

\subsection{快速排序quicksort}
