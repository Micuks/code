\subsubsection{算法类别}
Dijkstra单源最短路径算法属于贪心算法.

\subsubsection{问题描述}
给定带权有向图$G=(V,E)$, 其中每条边的权是\textbf{非负实数}. 另外, 还给定V中的一个顶点,
称为源. 现在要计算从源到所有其他各顶点的最短路长度.
此处的最短路长度指路上各边权之和. 这个问题通常称为\textbf{单源最短路径问题}.

\subsubsection{Dijkstra算法的基本思路}
求解的基本思路是, 设置顶点集合S并不断地进行贪心选择来扩充这个集合.
一个顶点属于集合S当且仅当从源到该顶点的最短路径长度已知.\par

初始的时候, S中仅含有源. 设u是G的某一个顶点,
把从源到u且中间只经过S中顶点的路称为从源到u的特殊路径,
并记录当前每个顶点所对应的最短特殊路径长度.
Dijkstra算法每次从V-S中取出具有最短特殊路径长度的顶点u, 将u添加到S中,
同时更新影响到的顶点所对应的最短特殊路径长度. 一旦S中包含了所有V中的顶点,
就已经完成了从源到其他顶点之间的最短路径长度.

\subsubsection{单源最短路径问题的的最优子结构性质}
对图$G(V, E)$, 源点v, 问题从以下三方面描述:
\begin{enumerate}
	\item 源点v, 途中顶点集合V在算法的迭代过程中均保持不变;
	\item 用于构造最短路径的当前顶点集合$S_i$, 不断增加, 定义不同规模的子问题;
	\item 指标: 相对于现有的$S_i$, 对各顶点u, 记录其到源点的距离u.distance.
\end{enumerate}

不同的$S_i$, 定义了不同规模的子问题; 当$S_i = V$的时候, 算法迭代结束,
此时$u.distance, \every u \in V$表示途中任意顶点到源的距离.\par

对越小的$S_i$, 问题越简单, 故自下而上求解.

\subsubsection{Dijkstra算法的贪心选择性质}
\begin{description}
	\item[贪心选择策略] 在每步迭代的时候, 从$V-S$
		中选择具有最短特殊路径u.dist的顶点u, 加入S.
	\item[贪心策略的正确性] 需要证明对顶点u, 从v开始,
		经过G中任意顶点到达u的全局最短路径长度$d(v, u) = u.dist$,
		其中u.dist是从v开始, 只经过S中的顶点到达u的最短路径.
		即不存在另一条v到u的最短路径, 使得其中某些节点在$V-S$中,
		且该路径的长度$d(v, u)< u.dist$.
\end{description}

使用反证法证明.\par

假设:
\begin{enumerate}
	\item 在迭代求解的过程中, 顶点u是V-U中u.dist最小的顶点,
	      且是第一个满足全局最短路径不完全在S集合中的顶点;
	\item 从v到u的全局最短路径上, 第一个属于$V-S$的顶点为x.
\end{enumerate}

则有:\par
首先, 因为u是\textbf{第一个}满足全局最短路径不完全在S集合中的顶点, 即
\begin{equation}
	d(v, u) < u.dist
	\label{equ:dijPro1}
\end{equation}
而x是在u之前遇到的顶点, x的最短路径完全在S中, 因此
\begin{equation}
	x.dist = d(v, x) \leq d(v, u)
	\label{equ:dijPro2}
\end{equation}
由式~\ref{equ:dijPro1}和式~\ref{equ:dijPro2}得,
\begin{equation}
	x.dist = d(v, x) \leq d(v, u) < u.dist
	\label{eq:dijPro3}
\end{equation}
但是, 由假设得, 顶点u是V-U中u.dist最小的顶点,
否则不会是dijkstra算法中选择的下一个V-U中的顶点, 即有
\begin{equation}
	u.dist \leq v.dist
\end{equation}
这与式~\ref{equ:dijPro3}中的$x.dist < u.dist$矛盾.\par
故贪心选择策略正确.

\subsubsection{Dijkstra的最优子结构性质}
对顶点i$(i | \every i \in V-U)$, 考察将u加入到S前后, i.dist的变化.
\begin{enumerate}
	\item 假设添加u后, 出现了一条从v到V-U中另一个节点i的新路,
	      该路径从v经过$S_{old}$中的顶点到达u, 再经过u的一条直接边到达i,
	      该路径的最短长度为$u.dist + w(u, i)$. 如果$u.dist+w(u,i) <
		      i.dist_{old}$, 则算法将更新i.dist. 否则, 不更新.
	\item 如果新路径先经过u, 再回到S中的x. 由于x比u先加入u中,
	      故x.dist已经是最短路径, $x.dist \leq u.dist + d(u, x)$. 此时,
	      从原v到i的最短路径i.dist小于路径$(v,u,x,i)$的长度,
	      保持算法更新i.dist的时候不需要考虑该路径, u的加入对dist[i]无影响.
\end{enumerate}
因此, 无论算法中i.dist的值是否变化, 它总是关于当前顶点集合S到顶点u的最短路径.
即对加入u之前和之后的$S_{old}$和$S_{new}$对应的两个子问题,
算法的执行过程保证了$(i.dist | \every i)$始终是i的最优解.
\subsubsection{关键函数及代码段的描述}
其伪代码描述如下:
\begin{algorithm}
	\caption{Dijkstra's algorithm}\label{alg:dijkstra}
	\begin{algorithmic}{1}
		\Require $(G, w, s)$
		\State $S = \emptyset$
		\State $Q = G.V$
		\While{$Q \neq \emptyset$}
		\State $u = Extract-Min(Q)$
		\State S = S \cup \{u\}
		\For{$each vertex v \in G.Adj[u]$}
		\State Relax(u, v, w)
		\EndFor
		\EndWhile
	\end{algorithmic}

	\begin{algorithmic}{1}
		Require $(u, v, w)$
		\If{$v.d > u.d + w(u, v)$}
		\State $v.d = u.d + w(u, v)$
		\EndIf
	\end{algorithmic}
\end{algorithm}

其核心代码实现如下:

% TODO: Add code here

\subsubsection{算法时间及空间复杂性分析}
\paragraph{空间复杂度分析}
Dijkstra算法使用了邻接表存储图, 对V个顶点, E条边的情况, 空间复杂度为$O(V+E)$.
在使用了二叉最小堆进行优化的情况下, 需要额外的$O(V)$空间用于存储二叉堆数组.

\paragraph{时间复杂度分析}
使用了二叉最小堆优化的Dijkstra算法对每一个顶点执行了一次Insert和Extract-Min操作.
因为每个顶点$u\in V$都被加入S一次,
邻接表Adj[u]中的每条边在for循环中也被检查了1次. 由于所有邻接表中边的数量为$|E|$,
故for循环重复了$|E|$次, 因此算法更新u.dist的次数最多为$|E|$次.\par

Dijkstra算法的时间复杂度与二叉最小堆的时间复杂度密切相关.
在二叉最小堆中, Extract-Min操作的开销为$O(lgV)$, 共进行$|V|$次.
建立二叉最小堆的时间为$O(V)$. 每次修改u.distance操作的开销为$O(lgV)$,
且最多有$|E|$次这样的操作. 故总时间复杂度为$O((V+E)lgV)$.
如果所有的顶点都能从源到达, 则总时间复杂度为$O(ElgV)$. 但是,
从原本的$O(V^2)$时间复杂度优化到$O(ElgV)$的前提是图是稀疏的, $E=o(V^2/lgV)$.
