\subsection{实现介绍}
\subsubsection{概述}
使用c语言标准库的sys/shm.h库创建共享内存, sys/sym.h创建和管理信号量, 使用fork()
创建多个子进程并分化位读者和写者.\par

程序使用调用程序的时候传入的命令行参数来设置共享内存大小, 读者和写者的总数, 以及
读者和写者的占比. \par

第一个参数为peers, 表示读者和写者进程的总数. 一般不超过3000, 否则操作系统将没有
多余的进程资源可以分配给其他进程请求, 影响操作系统正常运行.\par

第二个参数为rw\_ratio, 表示读者和写者的占比, 范围为$0, 1, \dots, 100$, 含义为每
个进程有rw\_ratio的概率变成读者.\par

第三个参数为shm\_size, 表示共享内存的大小, 即有多少块独立的共享内存可供访问.\par

程序代码结构如下.

\begin{code}
    ├── makefile
    ├── run.sh
    └── src
    ├── main_reader_priority.c
    ├── main_writer_priority.c
    ├── semaphores.c
    ├── semaphores.h
    ├── shared_memory.c
    └── shared_memory.h
\end{code}

源代码在src文件夹下, 其中:
\begin{itemize}
    \item main\_reader\_priority.c中是读者优先策略的主程序,
    \item main\_writer\_priority.c中是写者优先策略的主程序.
    \item semaphores.[ch]中封装了对信号量的操作, 包括对信号量的初始化和修改操作;
    \item shared\_memory.[ch]中封装了对共享内存的操作, 包括对共享内存的初始化和删除
          回收操作;
\end{itemize}

\subsubsection{共享内存}
共享内存定义在shared\_memory.[ch]中, 定义了如下操作:
\begin{code}
    /**
    * @brief Initialize shared memory.
    *
    * @param key
    * @param size
    * @return int
    */
    int shm_init(key_t key, int size);

    /**
    * @brief Return a pointer to memory.
    *
    * @param shm_id
    * @return shm_data*
    */
    ShmData *shm_at(int shm_id);

    /**
    * @brief Detach memory
    *
    * @param shm_ptr
    * @return int
    */
    int shm_detach(void *shm_ptr);

    /**
    * @brief Deallocate memory
    *
    * @param shm_id
    * @return int
    */
    int shm_delete(int shm_id);
\end{code}

\paragraph{共享数据}
实验中将多个共享数据结构体存储在共享内存中, 通过对多个共享数据结构体的并行访问和
控制模拟真实情况. 结构体定义如下.

\begin{code}
    typedef struct shm_data {
    int reads;
    int writes;
    } ShmData;
\end{code}

其中reads记录了写者的访问次数, writes记录了读者的访问次数.\\
为了模拟更加真实, 模拟多个共享数据如下.
\begin{code}
    // Initialize the shared matrix.
    // Allocate shared memory for ShmData.
    shm_id = shm_init(597, sizeof(ShmData) * shm_size);
    shmData = shm_at(shm_id);
    for (int i = 0; i < shm_size; i++) {
            shmData[i].writes = 0;
            shmData[i].reads = 0;
        }

\end{code}
其中597是shared\_memory key, 唯一标识一块共享内存. 在此处取学号后3位.

\paragraph{读者/写者计数器}
读者/写者计数器需要被多个读者或多个写者访问, 因此也存放在共享内存中, 使用信号量
控制访问. 信号量的介绍在下一节中. 读者/写者计数器初始化如下.
\begin{code}[caption={读者计数器}]
    // Initialize shared counter for readers
    readers_counter_id = shm_init((key_t)211, shm_size * sizeof(int));
    readers_counter_data = (int *)shm_at(readers_counter_id);
    for (size_t i = 0; i < (size_t)shm_size; i++) {
    readers_counter_data[i] = 0;
    }
\end{code}
初始化了大小为shm\_size * sizeof(int)的空间, shm\_size位共享数据所在共享内存的结
构体个数, 对每个结构体单独计数正在访问的读者数量.

为了实现写者优先, 本实验也用到了写者计数器, 类似读者计数器.
\begin{code}[caption={写者计数器}]
    // Initialize shared counter for writers
    writers_counter_id = shm_init((key_t)212, shm_size * sizeof(int));
    writers_counter_data = (int *)shm_at(writers_counter_id);
    for (size_t i = 0; i < (size_t)shm_size; i++) {
    writers_counter_data[i] = 0;
    }
\end{code}
初始化了大小为shm\_size * sizeof(int)的空间, shm\_size位共享数据所在共享内存的结
构体个数, 对每个结构体单独计数正在访问的写者数量.

\paragraph{统计信息共享内存}
为了统计所有读者/写者进程在进行预先设定好的轮数的共享内存访问时, 作为读者/写者的
等待时间总和, 设计了统计信息共享内存. 其初始化过程如下.
\begin{code}
    /** Initialize shared memory to keep stats
    * 0: Writer waiting time;
    * 1: Reader waiting time;
    * 2: Total waiting time;
    */
    shm_stat_id = shm_init((key_t)2022, 3 * sizeof(long));
    stat_data = (long *)shm_at(shm_stat_id);
    for (int i = 0; i < 3; i++) {
    stat_data[i] = 0;
    }

\end{code}
其中2022为这块共享内存的key. 每块共享内存存有3个long变量, 分别统计所有读者/写者
进程的总计等待时间, 读者等待时间和写者等待时间.

\textbf{注意} 由于程序中使用了usleep()来延长读者/写者占用共享内存的时间, 此时操
作系统不会分配给进程CPU clock, 因此使用clock()无法获取准确的休眠时间, 因此程序中
使用gettimeofday()的差值来计算经过的时间. 这个函数的返回值和时区相关, 由于只在东
八区(+8HRS)测试过, 所以不确定其他时区下表现是否有异常. 因此建议在\textbf{东八区}
使用该程序.

\subsubsection{信号量}
共有三组信号量, 封装信号量操作如下.
\begin{code}
    /**
    * @brief Create and initialize semaphore.
    *
    * @param key
    * @param sem_num
    * @return int
    */
    int sem_init(key_t key, int sem_num);

    /**
    * @brief Delete semaphore.
    *
    * @param sem_id
    * @param sem_num
    * @return int
    */
    int sem_del(int sem_id);

    /**
    * @brief Semaphore up.
    *
    * @param sem_id
    * @param sem_num
    * @return int
    */
    int sem_up(int sem_id, int sem_num);

    /**
    * @brief Sem down.
    *
    * @param sem_id
    * @param sem_num
    * @return int
    */
    int sem_down(int sem_id, int sem_num);

\end{code}

下面对三组信号量进行介绍.

\paragraph{第一组信号量}
第一组组信号量对共享内存中每个结构体单元的访问进行控制. 具体信号量初始化如下.
\begin{code}
    // Initialize semaphores.
    read_mutex = sem_init((key_t)10001, shm_size);
    write_mutex = sem_init((key_t)20001, shm_size);
    reader_counter_mutex = sem_init((key_t)30001, shm_size);
    writer_counter_mutex = sem_init((key_t)30002, shm_size);
    queue_mutex = sem_init((key_t)50001, shm_size);
    print_mutex = sem_init((key_t)40001, shm_size);
\end{code}
其中,
\begin{itemize}
    \item read\_mutex是读信号量, 用于控制读者进入关键区;
    \item  write\_mutex是写信号量, 用于控制读者进入关键区;
    \item  reader\_counter\_mutex是读者计数器信号量, 用于控制对读者计数器的访问权限;
    \item writer\_counter\_mutex是写者计数器信号量, 只在写者优先的主程序代码中出现,
          用于控制对写者计数器的访问权限;
    \item queue\_mutex是队列互斥锁信号量, 只在写者优先的主程序代码中出现, 用于控制
          是否允许读者进入等待访问共享内存的关键区的队列.
    \item print\_mutex用于控制不同进程写log到文件, 保证同一时间只有一个进程正在写log
          到文件.
\end{itemize}

\subsubsection{读者/写者分配}
第一个参数为peers, 表示读者和写者进程的总数. 一般不超过3000, 否则操作系统将没有
多余的进程资源可以分配给其他进程请求, 影响操作系统正常运行.\par

第二个参数为rw\_ratio, 表示读者和写者的占比, 范围为$0, 1, \dots, 100$, 含义为每
个进程有rw\_ratio的概率变成读者.\par

\subsubsection{读者优先策略}
\paragraph{写者进程}
成为写者的进程的操作伪代码如下. 对伪代码的解释在代码下方.
\begin{code}
    // child become writer
    entry = get random entry in shared memory.
writes++;

    /**
    * CRITICAL SECTION OF WRITER
    */
sem_down(write_mutex, entry);

// Sleep to occupy symaphore.
usleep(sleeptime);

shmData[entry].writes++;

sem_up(write_mutex, entry);
/**
* EXIT CRITICAL SECTION OF WRITER
*/

// Update statistic data.
total_time_writer += curr_time;
total_time += curr_time;

\end{code}

首先, 随机选择共享内存中一个共享数据结构体entry准备访问. 全局写次数writes+1.
之后wait(write\_mutex, entry)等待访问entry的读信号量, 并记录等待时间. 获取读信号
量后, 进入关键区, 使用usleep()来占用关键区一段时间模拟真实使用, 然后让该块共享内
存写次数+1. 然后退出共享内存, 更新该进程总写者时间和总时间.

\paragraph{读者进程}
成为读者的进程的操作伪代码如下. 对伪代码的解释在代码下方.
\begin{code}
entry =  Access a random shared data struct in shared memory.
reads++;

// Update counter.
sem_down(counter_mutex, entry);
readers_counter_data[entry]++;
if (readers_counter_data[entry] == 1) {
        // Prevent writer from entering critical section.
        sem_down(write_mutex, entry);
    }
sem_up(counter_mutex, entry);

/**
* CRITICAL SECTION OF READER
*/
sem_down(read_mutex, entry);

    // Sleep to occupy symaphore.
usleep(sleeptime);
shmData[entry].reads++;

sem_up(read_mutex, entry);
/**
* EXIT CRITICAL ZONE OF READER.
*/

// Update counter.
sem_down(counter_mutex, entry);
readers_counter_data[entry]--;
if (readers_counter_data[entry] == 0) {
        // Release writer lock.
        sem_up(write_mutex, entry);
    }
sem_up(counter_mutex, entry);

// Update timer.
total_time_reader += curr_time;
total_time += curr_time;
\end{code}
和写者进程一样, 首先随机选取一块待访问的共享内存, 然后增加进程阅读次数. 等待读者
计数器信号量后增加该块共享内存读者计数器. 如果读者计数器值为1, 则等待写者信号量,
以阻止写者进入关键区. 然后释放计数器信号量, 进入关键区. 等待读信号量, 然后使用
usleep()函数占用该块共享内存一段时间后, 增加该块共享内存的读次数, 释放读信号量.
等待读者计数器信号量, 减少该块共享内存读者计数器值. 如果读者计数器值为0, 释放写
者信号量, 允许写者进入共享内存. 然后释放该块共享内存读者计数器信号量. 更新总读者
等待时间和总等待时间.

\subsubsection{写者优先策略}
\paragraph{写者进程}
与读者优先策略相比, 写者进程增加了当有写者正在访问的时候阻止读者进入关键区队列的
操作. 具体伪代码和解释如下.
\begin{code}
// child become writer
entry = Access a random shared data struct in shared memory.
writes++;

// Update counter.
sem_down(writer_counter_mutex, entry);
writers_counter_data[entry]++;
if (writers_counter_data[entry] == 1) {
        // Prevent the following readers from entering queue.
        sem_down(queue_mutex, entry);
    }
sem_up(writer_counter_mutex, entry);

/**
* CRITICAL SECTION OF WRITER
*/
sem_down(write_mutex, entry);

// Sleep to occupy critical section.
    usleep(sleeptime);

    shmData[entry].writes++;

sem_up(write_mutex, entry);
    /**
    * EXIT CRITICAL SECTION OF WRITER
    */
// Update counter.
sem_down(writer_counter_mutex, entry);
writers_counter_data[entry]--;
if (writers_counter_data[entry] == 0) {
        // No writers waiting. Allow the following readers to
        // enqueue.
        sem_up(queue_mutex, entry);
    }
sem_up(writer_counter_mutex, entry);

    // Update statistic data.
    total_time_writer += curr_time;
    total_time += curr_time;

\end{code}

和读者优先策略中的写者一样, 首先随机选择一块共享内存中的结构体, 并增加进程总写次
数; 之后等待写者计数器信号量, 增加该共享内存块的写者计数器. 如果该共享内存块的写
者计数器值为1, 等待该共享内存块的队列信号量queue\_mutex, 以阻止后面的读者进入队
列. 然后释放该共享内存块的写者计数器信号量. 之后等待写者信号量write\_mutex, 进入
关键区, usleep()等待一段随机时间sleeptime后增加该块共享内存的写次数, 释放写信号
量, 退出关键区. 等待写者计数器信号量writers\_counter\_mutex, 减少该共享内存块写
者计数器计数. 如果写者计数器计数为0, 释放队列入口信号量queue\_mutex, 允许后面的
读者进入队列. 然后释放该共享内存块的写者计数器信号量.

\paragraph{读者进程}
相比读者优先策略下的读者, 写者优先策略下的读者增加了等待进入队列的操作, 以保证写
者能够优先访问关键区共享内存. 具体伪代码和解释如下.
\begin{code}
// child become reader.
    entry =  Access a random shared value in shared memory.
    reads++;

    // Wait for queue mutex.
    sem_down(queue_mutex, entry);

    // Update counter.
    sem_down(reader_counter_mutex, entry);
    readers_counter_data[entry]++;
    if (readers_counter_data[entry] == 1) {
            // Prevent writer from entering critical section.
            sem_down(write_mutex, entry);
        }

    // Release queue mutex.
    sem_up(queue_mutex, entry);
    // Release reader counter mutex.
    sem_up(reader_counter_mutex, entry);

    /**
    * CRITICAL SECTION OF READER
    */
    // Wait for read mutex.
    sem_down(read_mutex, entry);

    // Sleep to occupy symaphore.
    usleep(sleeptime);

    shmData[entry].reads++;

    sem_up(read_mutex, entry);
    /**
    * EXIT CRITICAL ZONE OF READER.
    */

    // Update counter.
    sem_down(reader_counter_mutex, entry);
    readers_counter_data[entry]--;
    if (readers_counter_data[entry] == 0) {
            // Release writer lock.
            sem_up(write_mutex, entry);
        }
    sem_up(reader_counter_mutex, entry);

    // Update timer.
    total_time_reader += curr_time;
    total_time += curr_time;

\end{code}

首先随机选择一块共享内存中的待访问结构体, 等待本块共享内存队列信号量queue\_mutex. 然后等待读
者计数器信号量reader\_counter\_mutex, 将该块共享内存的读者计数器数值增加. 如果读
者计数器的值为1, 等待信号量writer\_mutex, 阻止读者进入本块内存. 然后释放队列信号
量queue\_mutex和读者计数信号量reader\_counter\_mutex. 之后等待读信号量
read\_mutex, 进入关键区, usleep()等待一段随机时间sleeptime后增加本块共享内存的读
次数, 然后释放读信号量read\_mutex. 之后等待读者计数器信号量, 减少本块共享内存的
读者计数器数量, 释放读者计数器信号量, 如果读者计数器数值为0, 释放写信号量
write\_mutex, 允许后面的读者访问共享内存. 然后释放读者计数器信号量, 更新总读者等
待时间和总等待时间.\par

由于只要队列中有写者到来, 队列入口信号量queue\_mutex就会被占用, 导致之后来的读者
不能进入队列, 因此队列中的写者可以优先访问共享内存, 也就实现了写者优先策略.