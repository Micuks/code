// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: osi_featuredata.proto

#ifndef PROTOBUF_osi_5ffeaturedata_2eproto__INCLUDED
#define PROTOBUF_osi_5ffeaturedata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "osi_version.pb.h"
#include "osi_common.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_osi_5ffeaturedata_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[14];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsFeatureDataImpl();
void InitDefaultsFeatureData();
void InitDefaultsSensorDetectionHeaderImpl();
void InitDefaultsSensorDetectionHeader();
void InitDefaultsRadarDetectionDataImpl();
void InitDefaultsRadarDetectionData();
void InitDefaultsRadarDetectionImpl();
void InitDefaultsRadarDetection();
void InitDefaultsLidarDetectionDataImpl();
void InitDefaultsLidarDetectionData();
void InitDefaultsLidarDetectionImpl();
void InitDefaultsLidarDetection();
void InitDefaultsUltrasonicDetectionSpecificHeaderImpl();
void InitDefaultsUltrasonicDetectionSpecificHeader();
void InitDefaultsUltrasonicDetectionDataImpl();
void InitDefaultsUltrasonicDetectionData();
void InitDefaultsUltrasonicDetectionImpl();
void InitDefaultsUltrasonicDetection();
void InitDefaultsUltrasonicIndirectDetectionImpl();
void InitDefaultsUltrasonicIndirectDetection();
void InitDefaultsCameraDetectionSpecificHeaderImpl();
void InitDefaultsCameraDetectionSpecificHeader();
void InitDefaultsCameraDetectionDataImpl();
void InitDefaultsCameraDetectionData();
void InitDefaultsCameraDetectionImpl();
void InitDefaultsCameraDetection();
void InitDefaultsCameraPointImpl();
void InitDefaultsCameraPoint();
inline void InitDefaults() {
  InitDefaultsFeatureData();
  InitDefaultsSensorDetectionHeader();
  InitDefaultsRadarDetectionData();
  InitDefaultsRadarDetection();
  InitDefaultsLidarDetectionData();
  InitDefaultsLidarDetection();
  InitDefaultsUltrasonicDetectionSpecificHeader();
  InitDefaultsUltrasonicDetectionData();
  InitDefaultsUltrasonicDetection();
  InitDefaultsUltrasonicIndirectDetection();
  InitDefaultsCameraDetectionSpecificHeader();
  InitDefaultsCameraDetectionData();
  InitDefaultsCameraDetection();
  InitDefaultsCameraPoint();
}
}  // namespace protobuf_osi_5ffeaturedata_2eproto
namespace osi3 {
class CameraDetection;
class CameraDetectionDefaultTypeInternal;
extern CameraDetectionDefaultTypeInternal _CameraDetection_default_instance_;
class CameraDetectionData;
class CameraDetectionDataDefaultTypeInternal;
extern CameraDetectionDataDefaultTypeInternal _CameraDetectionData_default_instance_;
class CameraDetectionSpecificHeader;
class CameraDetectionSpecificHeaderDefaultTypeInternal;
extern CameraDetectionSpecificHeaderDefaultTypeInternal _CameraDetectionSpecificHeader_default_instance_;
class CameraPoint;
class CameraPointDefaultTypeInternal;
extern CameraPointDefaultTypeInternal _CameraPoint_default_instance_;
class FeatureData;
class FeatureDataDefaultTypeInternal;
extern FeatureDataDefaultTypeInternal _FeatureData_default_instance_;
class LidarDetection;
class LidarDetectionDefaultTypeInternal;
extern LidarDetectionDefaultTypeInternal _LidarDetection_default_instance_;
class LidarDetectionData;
class LidarDetectionDataDefaultTypeInternal;
extern LidarDetectionDataDefaultTypeInternal _LidarDetectionData_default_instance_;
class RadarDetection;
class RadarDetectionDefaultTypeInternal;
extern RadarDetectionDefaultTypeInternal _RadarDetection_default_instance_;
class RadarDetectionData;
class RadarDetectionDataDefaultTypeInternal;
extern RadarDetectionDataDefaultTypeInternal _RadarDetectionData_default_instance_;
class SensorDetectionHeader;
class SensorDetectionHeaderDefaultTypeInternal;
extern SensorDetectionHeaderDefaultTypeInternal _SensorDetectionHeader_default_instance_;
class UltrasonicDetection;
class UltrasonicDetectionDefaultTypeInternal;
extern UltrasonicDetectionDefaultTypeInternal _UltrasonicDetection_default_instance_;
class UltrasonicDetectionData;
class UltrasonicDetectionDataDefaultTypeInternal;
extern UltrasonicDetectionDataDefaultTypeInternal _UltrasonicDetectionData_default_instance_;
class UltrasonicDetectionSpecificHeader;
class UltrasonicDetectionSpecificHeaderDefaultTypeInternal;
extern UltrasonicDetectionSpecificHeaderDefaultTypeInternal _UltrasonicDetectionSpecificHeader_default_instance_;
class UltrasonicIndirectDetection;
class UltrasonicIndirectDetectionDefaultTypeInternal;
extern UltrasonicIndirectDetectionDefaultTypeInternal _UltrasonicIndirectDetection_default_instance_;
}  // namespace osi3
namespace osi3 {

enum SensorDetectionHeader_DataQualifier {
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_UNKNOWN = 0,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_OTHER = 1,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_AVAILABLE = 2,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_AVAILABLE_REDUCED = 3,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_NOT_AVAILABLE = 4,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_BLINDNESS = 5,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_TEMPORARY_AVAILABLE = 6,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_INVALID = 7,
  SensorDetectionHeader_DataQualifier_SensorDetectionHeader_DataQualifier_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SensorDetectionHeader_DataQualifier_SensorDetectionHeader_DataQualifier_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SensorDetectionHeader_DataQualifier_IsValid(int value);
const SensorDetectionHeader_DataQualifier SensorDetectionHeader_DataQualifier_DataQualifier_MIN = SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_UNKNOWN;
const SensorDetectionHeader_DataQualifier SensorDetectionHeader_DataQualifier_DataQualifier_MAX = SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_INVALID;
const int SensorDetectionHeader_DataQualifier_DataQualifier_ARRAYSIZE = SensorDetectionHeader_DataQualifier_DataQualifier_MAX + 1;

const ::google::protobuf::EnumDescriptor* SensorDetectionHeader_DataQualifier_descriptor();
inline const ::std::string& SensorDetectionHeader_DataQualifier_Name(SensorDetectionHeader_DataQualifier value) {
  return ::google::protobuf::internal::NameOfEnum(
    SensorDetectionHeader_DataQualifier_descriptor(), value);
}
inline bool SensorDetectionHeader_DataQualifier_Parse(
    const ::std::string& name, SensorDetectionHeader_DataQualifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorDetectionHeader_DataQualifier>(
    SensorDetectionHeader_DataQualifier_descriptor(), name, value);
}
enum SensorDetectionHeader_ExtendedQualifier {
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_UNKNOWN = 0,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_OTHER = 1,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_NORMAL_OPERATION_MODE = 2,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_POWER_UP_OR_DOWN = 3,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_SENSOR_NOT_CALIBRATED = 4,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_SENSOR_BLOCKED = 5,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_SENSOR_MISALIGNED = 6,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_BAD_SENSOR_ENVIRONMENTAL_CONDITION = 7,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_REDUCED_FIELD_OF_VIEW = 8,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_INPUT_NOT_AVAILABLE = 9,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_INTERNAL_REASON = 10,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_EXTERNAL_DISTURBANCE = 11,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_BEGINNING_BLOCKAGE = 12,
  SensorDetectionHeader_ExtendedQualifier_SensorDetectionHeader_ExtendedQualifier_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SensorDetectionHeader_ExtendedQualifier_SensorDetectionHeader_ExtendedQualifier_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SensorDetectionHeader_ExtendedQualifier_IsValid(int value);
const SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_MIN = SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_UNKNOWN;
const SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_MAX = SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_BEGINNING_BLOCKAGE;
const int SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_ARRAYSIZE = SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_MAX + 1;

const ::google::protobuf::EnumDescriptor* SensorDetectionHeader_ExtendedQualifier_descriptor();
inline const ::std::string& SensorDetectionHeader_ExtendedQualifier_Name(SensorDetectionHeader_ExtendedQualifier value) {
  return ::google::protobuf::internal::NameOfEnum(
    SensorDetectionHeader_ExtendedQualifier_descriptor(), value);
}
inline bool SensorDetectionHeader_ExtendedQualifier_Parse(
    const ::std::string& name, SensorDetectionHeader_ExtendedQualifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorDetectionHeader_ExtendedQualifier>(
    SensorDetectionHeader_ExtendedQualifier_descriptor(), name, value);
}
enum CameraDetection_Color {
  CameraDetection_Color_COLOR_UNKNOWN = 0,
  CameraDetection_Color_COLOR_OTHER = 1,
  CameraDetection_Color_COLOR_BLACK = 2,
  CameraDetection_Color_COLOR_GREY = 3,
  CameraDetection_Color_COLOR_WHITE = 4,
  CameraDetection_Color_COLOR_YELLOW = 5,
  CameraDetection_Color_COLOR_ORANGE = 6,
  CameraDetection_Color_COLOR_RED = 7,
  CameraDetection_Color_COLOR_VIOLET = 8,
  CameraDetection_Color_COLOR_BLUE = 9,
  CameraDetection_Color_COLOR_GREEN = 10,
  CameraDetection_Color_COLOR_REFLECTIVE = 11,
  CameraDetection_Color_CameraDetection_Color_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CameraDetection_Color_CameraDetection_Color_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CameraDetection_Color_IsValid(int value);
const CameraDetection_Color CameraDetection_Color_Color_MIN = CameraDetection_Color_COLOR_UNKNOWN;
const CameraDetection_Color CameraDetection_Color_Color_MAX = CameraDetection_Color_COLOR_REFLECTIVE;
const int CameraDetection_Color_Color_ARRAYSIZE = CameraDetection_Color_Color_MAX + 1;

const ::google::protobuf::EnumDescriptor* CameraDetection_Color_descriptor();
inline const ::std::string& CameraDetection_Color_Name(CameraDetection_Color value) {
  return ::google::protobuf::internal::NameOfEnum(
    CameraDetection_Color_descriptor(), value);
}
inline bool CameraDetection_Color_Parse(
    const ::std::string& name, CameraDetection_Color* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CameraDetection_Color>(
    CameraDetection_Color_descriptor(), name, value);
}
enum CameraDetection_ImageShapeType {
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_UNKNOWN = 0,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_OTHER = 1,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POINT = 2,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_BOX = 3,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_ELLIPSE = 4,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POLYGON = 5,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POLYLINE = 6,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POINT_CLOUD = 7,
  CameraDetection_ImageShapeType_CameraDetection_ImageShapeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CameraDetection_ImageShapeType_CameraDetection_ImageShapeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CameraDetection_ImageShapeType_IsValid(int value);
const CameraDetection_ImageShapeType CameraDetection_ImageShapeType_ImageShapeType_MIN = CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_UNKNOWN;
const CameraDetection_ImageShapeType CameraDetection_ImageShapeType_ImageShapeType_MAX = CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POINT_CLOUD;
const int CameraDetection_ImageShapeType_ImageShapeType_ARRAYSIZE = CameraDetection_ImageShapeType_ImageShapeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CameraDetection_ImageShapeType_descriptor();
inline const ::std::string& CameraDetection_ImageShapeType_Name(CameraDetection_ImageShapeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CameraDetection_ImageShapeType_descriptor(), value);
}
inline bool CameraDetection_ImageShapeType_Parse(
    const ::std::string& name, CameraDetection_ImageShapeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CameraDetection_ImageShapeType>(
    CameraDetection_ImageShapeType_descriptor(), name, value);
}
enum DetectionClassification {
  DETECTION_CLASSIFICATION_UNKNOWN = 0,
  DETECTION_CLASSIFICATION_OTHER = 1,
  DETECTION_CLASSIFICATION_INVALID = 2,
  DETECTION_CLASSIFICATION_CLUTTER = 3,
  DETECTION_CLASSIFICATION_OVERDRIVABLE = 4,
  DETECTION_CLASSIFICATION_UNDERDRIVABLE = 5,
  DetectionClassification_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DetectionClassification_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DetectionClassification_IsValid(int value);
const DetectionClassification DetectionClassification_MIN = DETECTION_CLASSIFICATION_UNKNOWN;
const DetectionClassification DetectionClassification_MAX = DETECTION_CLASSIFICATION_UNDERDRIVABLE;
const int DetectionClassification_ARRAYSIZE = DetectionClassification_MAX + 1;

const ::google::protobuf::EnumDescriptor* DetectionClassification_descriptor();
inline const ::std::string& DetectionClassification_Name(DetectionClassification value) {
  return ::google::protobuf::internal::NameOfEnum(
    DetectionClassification_descriptor(), value);
}
inline bool DetectionClassification_Parse(
    const ::std::string& name, DetectionClassification* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DetectionClassification>(
    DetectionClassification_descriptor(), name, value);
}
// ===================================================================

class FeatureData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:osi3.FeatureData) */ {
 public:
  FeatureData();
  virtual ~FeatureData();

  FeatureData(const FeatureData& from);

  inline FeatureData& operator=(const FeatureData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FeatureData(FeatureData&& from) noexcept
    : FeatureData() {
    *this = ::std::move(from);
  }

  inline FeatureData& operator=(FeatureData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeatureData* internal_default_instance() {
    return reinterpret_cast<const FeatureData*>(
               &_FeatureData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(FeatureData* other);
  friend void swap(FeatureData& a, FeatureData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FeatureData* New() const PROTOBUF_FINAL { return New(NULL); }

  FeatureData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FeatureData& from);
  void MergeFrom(const FeatureData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FeatureData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .osi3.RadarDetectionData radar_sensor = 2;
  int radar_sensor_size() const;
  void clear_radar_sensor();
  static const int kRadarSensorFieldNumber = 2;
  const ::osi3::RadarDetectionData& radar_sensor(int index) const;
  ::osi3::RadarDetectionData* mutable_radar_sensor(int index);
  ::osi3::RadarDetectionData* add_radar_sensor();
  ::google::protobuf::RepeatedPtrField< ::osi3::RadarDetectionData >*
      mutable_radar_sensor();
  const ::google::protobuf::RepeatedPtrField< ::osi3::RadarDetectionData >&
      radar_sensor() const;

  // repeated .osi3.LidarDetectionData lidar_sensor = 3;
  int lidar_sensor_size() const;
  void clear_lidar_sensor();
  static const int kLidarSensorFieldNumber = 3;
  const ::osi3::LidarDetectionData& lidar_sensor(int index) const;
  ::osi3::LidarDetectionData* mutable_lidar_sensor(int index);
  ::osi3::LidarDetectionData* add_lidar_sensor();
  ::google::protobuf::RepeatedPtrField< ::osi3::LidarDetectionData >*
      mutable_lidar_sensor();
  const ::google::protobuf::RepeatedPtrField< ::osi3::LidarDetectionData >&
      lidar_sensor() const;

  // repeated .osi3.UltrasonicDetectionData ultrasonic_sensor = 4;
  int ultrasonic_sensor_size() const;
  void clear_ultrasonic_sensor();
  static const int kUltrasonicSensorFieldNumber = 4;
  const ::osi3::UltrasonicDetectionData& ultrasonic_sensor(int index) const;
  ::osi3::UltrasonicDetectionData* mutable_ultrasonic_sensor(int index);
  ::osi3::UltrasonicDetectionData* add_ultrasonic_sensor();
  ::google::protobuf::RepeatedPtrField< ::osi3::UltrasonicDetectionData >*
      mutable_ultrasonic_sensor();
  const ::google::protobuf::RepeatedPtrField< ::osi3::UltrasonicDetectionData >&
      ultrasonic_sensor() const;

  // repeated .osi3.CameraDetectionData camera_sensor = 5;
  int camera_sensor_size() const;
  void clear_camera_sensor();
  static const int kCameraSensorFieldNumber = 5;
  const ::osi3::CameraDetectionData& camera_sensor(int index) const;
  ::osi3::CameraDetectionData* mutable_camera_sensor(int index);
  ::osi3::CameraDetectionData* add_camera_sensor();
  ::google::protobuf::RepeatedPtrField< ::osi3::CameraDetectionData >*
      mutable_camera_sensor();
  const ::google::protobuf::RepeatedPtrField< ::osi3::CameraDetectionData >&
      camera_sensor() const;

  // .osi3.InterfaceVersion version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::osi3::InterfaceVersion& version() const;
  ::osi3::InterfaceVersion* release_version();
  ::osi3::InterfaceVersion* mutable_version();
  void set_allocated_version(::osi3::InterfaceVersion* version);

  // @@protoc_insertion_point(class_scope:osi3.FeatureData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::osi3::RadarDetectionData > radar_sensor_;
  ::google::protobuf::RepeatedPtrField< ::osi3::LidarDetectionData > lidar_sensor_;
  ::google::protobuf::RepeatedPtrField< ::osi3::UltrasonicDetectionData > ultrasonic_sensor_;
  ::google::protobuf::RepeatedPtrField< ::osi3::CameraDetectionData > camera_sensor_;
  ::osi3::InterfaceVersion* version_;
  mutable int _cached_size_;
  friend struct ::protobuf_osi_5ffeaturedata_2eproto::TableStruct;
  friend void ::protobuf_osi_5ffeaturedata_2eproto::InitDefaultsFeatureDataImpl();
};
// -------------------------------------------------------------------

class SensorDetectionHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:osi3.SensorDetectionHeader) */ {
 public:
  SensorDetectionHeader();
  virtual ~SensorDetectionHeader();

  SensorDetectionHeader(const SensorDetectionHeader& from);

  inline SensorDetectionHeader& operator=(const SensorDetectionHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorDetectionHeader(SensorDetectionHeader&& from) noexcept
    : SensorDetectionHeader() {
    *this = ::std::move(from);
  }

  inline SensorDetectionHeader& operator=(SensorDetectionHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorDetectionHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorDetectionHeader* internal_default_instance() {
    return reinterpret_cast<const SensorDetectionHeader*>(
               &_SensorDetectionHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SensorDetectionHeader* other);
  friend void swap(SensorDetectionHeader& a, SensorDetectionHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorDetectionHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  SensorDetectionHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SensorDetectionHeader& from);
  void MergeFrom(const SensorDetectionHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SensorDetectionHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SensorDetectionHeader_DataQualifier DataQualifier;
  static const DataQualifier DATA_QUALIFIER_UNKNOWN =
    SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_UNKNOWN;
  static const DataQualifier DATA_QUALIFIER_OTHER =
    SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_OTHER;
  static const DataQualifier DATA_QUALIFIER_AVAILABLE =
    SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_AVAILABLE;
  static const DataQualifier DATA_QUALIFIER_AVAILABLE_REDUCED =
    SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_AVAILABLE_REDUCED;
  static const DataQualifier DATA_QUALIFIER_NOT_AVAILABLE =
    SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_NOT_AVAILABLE;
  static const DataQualifier DATA_QUALIFIER_BLINDNESS =
    SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_BLINDNESS;
  static const DataQualifier DATA_QUALIFIER_TEMPORARY_AVAILABLE =
    SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_TEMPORARY_AVAILABLE;
  static const DataQualifier DATA_QUALIFIER_INVALID =
    SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_INVALID;
  static inline bool DataQualifier_IsValid(int value) {
    return SensorDetectionHeader_DataQualifier_IsValid(value);
  }
  static const DataQualifier DataQualifier_MIN =
    SensorDetectionHeader_DataQualifier_DataQualifier_MIN;
  static const DataQualifier DataQualifier_MAX =
    SensorDetectionHeader_DataQualifier_DataQualifier_MAX;
  static const int DataQualifier_ARRAYSIZE =
    SensorDetectionHeader_DataQualifier_DataQualifier_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DataQualifier_descriptor() {
    return SensorDetectionHeader_DataQualifier_descriptor();
  }
  static inline const ::std::string& DataQualifier_Name(DataQualifier value) {
    return SensorDetectionHeader_DataQualifier_Name(value);
  }
  static inline bool DataQualifier_Parse(const ::std::string& name,
      DataQualifier* value) {
    return SensorDetectionHeader_DataQualifier_Parse(name, value);
  }

  typedef SensorDetectionHeader_ExtendedQualifier ExtendedQualifier;
  static const ExtendedQualifier EXTENDED_QUALIFIER_UNKNOWN =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_UNKNOWN;
  static const ExtendedQualifier EXTENDED_QUALIFIER_OTHER =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_OTHER;
  static const ExtendedQualifier EXTENDED_QUALIFIER_NORMAL_OPERATION_MODE =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_NORMAL_OPERATION_MODE;
  static const ExtendedQualifier EXTENDED_QUALIFIER_POWER_UP_OR_DOWN =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_POWER_UP_OR_DOWN;
  static const ExtendedQualifier EXTENDED_QUALIFIER_SENSOR_NOT_CALIBRATED =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_SENSOR_NOT_CALIBRATED;
  static const ExtendedQualifier EXTENDED_QUALIFIER_SENSOR_BLOCKED =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_SENSOR_BLOCKED;
  static const ExtendedQualifier EXTENDED_QUALIFIER_SENSOR_MISALIGNED =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_SENSOR_MISALIGNED;
  static const ExtendedQualifier EXTENDED_QUALIFIER_BAD_SENSOR_ENVIRONMENTAL_CONDITION =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_BAD_SENSOR_ENVIRONMENTAL_CONDITION;
  static const ExtendedQualifier EXTENDED_QUALIFIER_REDUCED_FIELD_OF_VIEW =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_REDUCED_FIELD_OF_VIEW;
  static const ExtendedQualifier EXTENDED_QUALIFIER_INPUT_NOT_AVAILABLE =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_INPUT_NOT_AVAILABLE;
  static const ExtendedQualifier EXTENDED_QUALIFIER_INTERNAL_REASON =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_INTERNAL_REASON;
  static const ExtendedQualifier EXTENDED_QUALIFIER_EXTERNAL_DISTURBANCE =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_EXTERNAL_DISTURBANCE;
  static const ExtendedQualifier EXTENDED_QUALIFIER_BEGINNING_BLOCKAGE =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_BEGINNING_BLOCKAGE;
  static inline bool ExtendedQualifier_IsValid(int value) {
    return SensorDetectionHeader_ExtendedQualifier_IsValid(value);
  }
  static const ExtendedQualifier ExtendedQualifier_MIN =
    SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_MIN;
  static const ExtendedQualifier ExtendedQualifier_MAX =
    SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_MAX;
  static const int ExtendedQualifier_ARRAYSIZE =
    SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExtendedQualifier_descriptor() {
    return SensorDetectionHeader_ExtendedQualifier_descriptor();
  }
  static inline const ::std::string& ExtendedQualifier_Name(ExtendedQualifier value) {
    return SensorDetectionHeader_ExtendedQualifier_Name(value);
  }
  static inline bool ExtendedQualifier_Parse(const ::std::string& name,
      ExtendedQualifier* value) {
    return SensorDetectionHeader_ExtendedQualifier_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .osi3.Timestamp measurement_time = 1;
  bool has_measurement_time() const;
  void clear_measurement_time();
  static const int kMeasurementTimeFieldNumber = 1;
  const ::osi3::Timestamp& measurement_time() const;
  ::osi3::Timestamp* release_measurement_time();
  ::osi3::Timestamp* mutable_measurement_time();
  void set_allocated_measurement_time(::osi3::Timestamp* measurement_time);

  // .osi3.MountingPosition mounting_position = 3;
  bool has_mounting_position() const;
  void clear_mounting_position();
  static const int kMountingPositionFieldNumber = 3;
  const ::osi3::MountingPosition& mounting_position() const;
  ::osi3::MountingPosition* release_mounting_position();
  ::osi3::MountingPosition* mutable_mounting_position();
  void set_allocated_mounting_position(::osi3::MountingPosition* mounting_position);

  // .osi3.MountingPosition mounting_position_rmse = 4;
  bool has_mounting_position_rmse() const;
  void clear_mounting_position_rmse();
  static const int kMountingPositionRmseFieldNumber = 4;
  const ::osi3::MountingPosition& mounting_position_rmse() const;
  ::osi3::MountingPosition* release_mounting_position_rmse();
  ::osi3::MountingPosition* mutable_mounting_position_rmse();
  void set_allocated_mounting_position_rmse(::osi3::MountingPosition* mounting_position_rmse);

  // .osi3.Identifier sensor_id = 7;
  bool has_sensor_id() const;
  void clear_sensor_id();
  static const int kSensorIdFieldNumber = 7;
  const ::osi3::Identifier& sensor_id() const;
  ::osi3::Identifier* release_sensor_id();
  ::osi3::Identifier* mutable_sensor_id();
  void set_allocated_sensor_id(::osi3::Identifier* sensor_id);

  // uint64 cycle_counter = 2;
  void clear_cycle_counter();
  static const int kCycleCounterFieldNumber = 2;
  ::google::protobuf::uint64 cycle_counter() const;
  void set_cycle_counter(::google::protobuf::uint64 value);

  // .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
  void clear_data_qualifier();
  static const int kDataQualifierFieldNumber = 5;
  ::osi3::SensorDetectionHeader_DataQualifier data_qualifier() const;
  void set_data_qualifier(::osi3::SensorDetectionHeader_DataQualifier value);

  // uint32 number_of_valid_detections = 6;
  void clear_number_of_valid_detections();
  static const int kNumberOfValidDetectionsFieldNumber = 6;
  ::google::protobuf::uint32 number_of_valid_detections() const;
  void set_number_of_valid_detections(::google::protobuf::uint32 value);

  // .osi3.SensorDetectionHeader.ExtendedQualifier extended_qualifier = 8;
  void clear_extended_qualifier();
  static const int kExtendedQualifierFieldNumber = 8;
  ::osi3::SensorDetectionHeader_ExtendedQualifier extended_qualifier() const;
  void set_extended_qualifier(::osi3::SensorDetectionHeader_ExtendedQualifier value);

  // @@protoc_insertion_point(class_scope:osi3.SensorDetectionHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::osi3::Timestamp* measurement_time_;
  ::osi3::MountingPosition* mounting_position_;
  ::osi3::MountingPosition* mounting_position_rmse_;
  ::osi3::Identifier* sensor_id_;
  ::google::protobuf::uint64 cycle_counter_;
  int data_qualifier_;
  ::google::protobuf::uint32 number_of_valid_detections_;
  int extended_qualifier_;
  mutable int _cached_size_;
  friend struct ::protobuf_osi_5ffeaturedata_2eproto::TableStruct;
  friend void ::protobuf_osi_5ffeaturedata_2eproto::InitDefaultsSensorDetectionHeaderImpl();
};
// -------------------------------------------------------------------

class RadarDetectionData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:osi3.RadarDetectionData) */ {
 public:
  RadarDetectionData();
  virtual ~RadarDetectionData();

  RadarDetectionData(const RadarDetectionData& from);

  inline RadarDetectionData& operator=(const RadarDetectionData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RadarDetectionData(RadarDetectionData&& from) noexcept
    : RadarDetectionData() {
    *this = ::std::move(from);
  }

  inline RadarDetectionData& operator=(RadarDetectionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RadarDetectionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RadarDetectionData* internal_default_instance() {
    return reinterpret_cast<const RadarDetectionData*>(
               &_RadarDetectionData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RadarDetectionData* other);
  friend void swap(RadarDetectionData& a, RadarDetectionData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RadarDetectionData* New() const PROTOBUF_FINAL { return New(NULL); }

  RadarDetectionData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RadarDetectionData& from);
  void MergeFrom(const RadarDetectionData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RadarDetectionData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .osi3.RadarDetection detection = 2;
  int detection_size() const;
  void clear_detection();
  static const int kDetectionFieldNumber = 2;
  const ::osi3::RadarDetection& detection(int index) const;
  ::osi3::RadarDetection* mutable_detection(int index);
  ::osi3::RadarDetection* add_detection();
  ::google::protobuf::RepeatedPtrField< ::osi3::RadarDetection >*
      mutable_detection();
  const ::google::protobuf::RepeatedPtrField< ::osi3::RadarDetection >&
      detection() const;

  // .osi3.SensorDetectionHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::osi3::SensorDetectionHeader& header() const;
  ::osi3::SensorDetectionHeader* release_header();
  ::osi3::SensorDetectionHeader* mutable_header();
  void set_allocated_header(::osi3::SensorDetectionHeader* header);

  // @@protoc_insertion_point(class_scope:osi3.RadarDetectionData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::osi3::RadarDetection > detection_;
  ::osi3::SensorDetectionHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_osi_5ffeaturedata_2eproto::TableStruct;
  friend void ::protobuf_osi_5ffeaturedata_2eproto::InitDefaultsRadarDetectionDataImpl();
};
// -------------------------------------------------------------------

class RadarDetection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:osi3.RadarDetection) */ {
 public:
  RadarDetection();
  virtual ~RadarDetection();

  RadarDetection(const RadarDetection& from);

  inline RadarDetection& operator=(const RadarDetection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RadarDetection(RadarDetection&& from) noexcept
    : RadarDetection() {
    *this = ::std::move(from);
  }

  inline RadarDetection& operator=(RadarDetection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RadarDetection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RadarDetection* internal_default_instance() {
    return reinterpret_cast<const RadarDetection*>(
               &_RadarDetection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(RadarDetection* other);
  friend void swap(RadarDetection& a, RadarDetection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RadarDetection* New() const PROTOBUF_FINAL { return New(NULL); }

  RadarDetection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RadarDetection& from);
  void MergeFrom(const RadarDetection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RadarDetection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .osi3.Identifier object_id = 2;
  bool has_object_id() const;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 2;
  const ::osi3::Identifier& object_id() const;
  ::osi3::Identifier* release_object_id();
  ::osi3::Identifier* mutable_object_id();
  void set_allocated_object_id(::osi3::Identifier* object_id);

  // .osi3.Spherical3d position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  const ::osi3::Spherical3d& position() const;
  ::osi3::Spherical3d* release_position();
  ::osi3::Spherical3d* mutable_position();
  void set_allocated_position(::osi3::Spherical3d* position);

  // .osi3.Spherical3d position_rmse = 4;
  bool has_position_rmse() const;
  void clear_position_rmse();
  static const int kPositionRmseFieldNumber = 4;
  const ::osi3::Spherical3d& position_rmse() const;
  ::osi3::Spherical3d* release_position_rmse();
  ::osi3::Spherical3d* mutable_position_rmse();
  void set_allocated_position_rmse(::osi3::Spherical3d* position_rmse);

  // .osi3.Identifier ambiguity_id = 10;
  bool has_ambiguity_id() const;
  void clear_ambiguity_id();
  static const int kAmbiguityIdFieldNumber = 10;
  const ::osi3::Identifier& ambiguity_id() const;
  ::osi3::Identifier* release_ambiguity_id();
  ::osi3::Identifier* mutable_ambiguity_id();
  void set_allocated_ambiguity_id(::osi3::Identifier* ambiguity_id);

  // double existence_probability = 1;
  void clear_existence_probability();
  static const int kExistenceProbabilityFieldNumber = 1;
  double existence_probability() const;
  void set_existence_probability(double value);

  // double radial_velocity = 5;
  void clear_radial_velocity();
  static const int kRadialVelocityFieldNumber = 5;
  double radial_velocity() const;
  void set_radial_velocity(double value);

  // double radial_velocity_rmse = 6;
  void clear_radial_velocity_rmse();
  static const int kRadialVelocityRmseFieldNumber = 6;
  double radial_velocity_rmse() const;
  void set_radial_velocity_rmse(double value);

  // double rcs = 7;
  void clear_rcs();
  static const int kRcsFieldNumber = 7;
  double rcs() const;
  void set_rcs(double value);

  // double snr = 8;
  void clear_snr();
  static const int kSnrFieldNumber = 8;
  double snr() const;
  void set_snr(double value);

  // double point_target_probability = 9;
  void clear_point_target_probability();
  static const int kPointTargetProbabilityFieldNumber = 9;
  double point_target_probability() const;
  void set_point_target_probability(double value);

  // .osi3.DetectionClassification classification = 11;
  void clear_classification();
  static const int kClassificationFieldNumber = 11;
  ::osi3::DetectionClassification classification() const;
  void set_classification(::osi3::DetectionClassification value);

  // @@protoc_insertion_point(class_scope:osi3.RadarDetection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::osi3::Identifier* object_id_;
  ::osi3::Spherical3d* position_;
  ::osi3::Spherical3d* position_rmse_;
  ::osi3::Identifier* ambiguity_id_;
  double existence_probability_;
  double radial_velocity_;
  double radial_velocity_rmse_;
  double rcs_;
  double snr_;
  double point_target_probability_;
  int classification_;
  mutable int _cached_size_;
  friend struct ::protobuf_osi_5ffeaturedata_2eproto::TableStruct;
  friend void ::protobuf_osi_5ffeaturedata_2eproto::InitDefaultsRadarDetectionImpl();
};
// -------------------------------------------------------------------

class LidarDetectionData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:osi3.LidarDetectionData) */ {
 public:
  LidarDetectionData();
  virtual ~LidarDetectionData();

  LidarDetectionData(const LidarDetectionData& from);

  inline LidarDetectionData& operator=(const LidarDetectionData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LidarDetectionData(LidarDetectionData&& from) noexcept
    : LidarDetectionData() {
    *this = ::std::move(from);
  }

  inline LidarDetectionData& operator=(LidarDetectionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LidarDetectionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LidarDetectionData* internal_default_instance() {
    return reinterpret_cast<const LidarDetectionData*>(
               &_LidarDetectionData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(LidarDetectionData* other);
  friend void swap(LidarDetectionData& a, LidarDetectionData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LidarDetectionData* New() const PROTOBUF_FINAL { return New(NULL); }

  LidarDetectionData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LidarDetectionData& from);
  void MergeFrom(const LidarDetectionData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LidarDetectionData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .osi3.LidarDetection detection = 2;
  int detection_size() const;
  void clear_detection();
  static const int kDetectionFieldNumber = 2;
  const ::osi3::LidarDetection& detection(int index) const;
  ::osi3::LidarDetection* mutable_detection(int index);
  ::osi3::LidarDetection* add_detection();
  ::google::protobuf::RepeatedPtrField< ::osi3::LidarDetection >*
      mutable_detection();
  const ::google::protobuf::RepeatedPtrField< ::osi3::LidarDetection >&
      detection() const;

  // .osi3.SensorDetectionHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::osi3::SensorDetectionHeader& header() const;
  ::osi3::SensorDetectionHeader* release_header();
  ::osi3::SensorDetectionHeader* mutable_header();
  void set_allocated_header(::osi3::SensorDetectionHeader* header);

  // @@protoc_insertion_point(class_scope:osi3.LidarDetectionData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::osi3::LidarDetection > detection_;
  ::osi3::SensorDetectionHeader* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_osi_5ffeaturedata_2eproto::TableStruct;
  friend void ::protobuf_osi_5ffeaturedata_2eproto::InitDefaultsLidarDetectionDataImpl();
};
// -------------------------------------------------------------------

class LidarDetection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:osi3.LidarDetection) */ {
 public:
  LidarDetection();
  virtual ~LidarDetection();

  LidarDetection(const LidarDetection& from);

  inline LidarDetection& operator=(const LidarDetection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LidarDetection(LidarDetection&& from) noexcept
    : LidarDetection() {
    *this = ::std::move(from);
  }

  inline LidarDetection& operator=(LidarDetection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LidarDetection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LidarDetection* internal_default_instance() {
    return reinterpret_cast<const LidarDetection*>(
               &_LidarDetection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(LidarDetection* other);
  friend void swap(LidarDetection& a, LidarDetection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LidarDetection* New() const PROTOBUF_FINAL { return New(NULL); }

  LidarDetection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LidarDetection& from);
  void MergeFrom(const LidarDetection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LidarDetection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .osi3.Identifier object_id = 2;
  bool has_object_id() const;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 2;
  const ::osi3::Identifier& object_id() const;
  ::osi3::Identifier* release_object_id();
  ::osi3::Identifier* mutable_object_id();
  void set_allocated_object_id(::osi3::Identifier* object_id);

  // .osi3.Spherical3d position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  const ::osi3::Spherical3d& position() const;
  ::osi3::Spherical3d* release_position();
  ::osi3::Spherical3d* mutable_position();
  void set_allocated_position(::osi3::Spherical3d* position);

  // .osi3.Spherical3d position_rmse = 4;
  bool has_position_rmse() const;
  void clear_position_rmse();
  static const int kPositionRmseFieldNumber = 4;
  const ::osi3::Spherical3d& position_rmse() const;
  ::osi3::Spherical3d* release_position_rmse();
  ::osi3::Spherical3d* mutable_position_rmse();
  void set_allocated_position_rmse(::osi3::Spherical3d* position_rmse);

  // double existence_probability = 1;
  void clear_existence_probability();
  static const int kExistenceProbabilityFieldNumber = 1;
  double existence_probability() const;
  void set_existence_probability(double value);

  // double height = 5;
  void clear_height();
  static const int kHeightFieldNumber = 5;
  double height() const;
  void set_height(double value);

  // double height_rmse = 6;
  void clear_height_rmse();
  static const int kHeightRmseFieldNumber = 6;
  double height_rmse() const;
  void set_height_rmse(double value);

  // double intensity = 7;
  void clear_intensity();
  static const int kIntensityFieldNumber = 7;
  double intensity() const;
  void set_intensity(double value);

  // double free_space_probability = 8;
  void clear_free_space_probability();
  static const int kFreeSpaceProbabilityFieldNumber = 8;
  double free_space_probability() const;
  void set_free_space_probability(double value);

  // double reflectivity = 10;
  void clear_reflectivity();
  static const int kReflectivityFieldNumber = 10;
  double reflectivity() const;
  void set_reflectivity(double value);

  // .osi3.DetectionClassification classification = 9;
  void clear_classification();
  static const int kClassificationFieldNumber = 9;
  ::osi3::DetectionClassification classification() const;
  void set_classification(::osi3::DetectionClassification value);

  // @@protoc_insertion_point(class_scope:osi3.LidarDetection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::osi3::Identifier* object_id_;
  ::osi3::Spherical3d* position_;
  ::osi3::Spherical3d* position_rmse_;
  double existence_probability_;
  double height_;
  double height_rmse_;
  double intensity_;
  double free_space_probability_;
  double reflectivity_;
  int classification_;
  mutable int _cached_size_;
  friend struct ::protobuf_osi_5ffeaturedata_2eproto::TableStruct;
  friend void ::protobuf_osi_5ffeaturedata_2eproto::InitDefaultsLidarDetectionImpl();
};
// -------------------------------------------------------------------

class UltrasonicDetectionSpecificHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:osi3.UltrasonicDetectionSpecificHeader) */ {
 public:
  UltrasonicDetectionSpecificHeader();
  virtual ~UltrasonicDetectionSpecificHeader();

  UltrasonicDetectionSpecificHeader(const UltrasonicDetectionSpecificHeader& from);

  inline UltrasonicDetectionSpecificHeader& operator=(const UltrasonicDetectionSpecificHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UltrasonicDetectionSpecificHeader(UltrasonicDetectionSpecificHeader&& from) noexcept
    : UltrasonicDetectionSpecificHeader() {
    *this = ::std::move(from);
  }

  inline UltrasonicDetectionSpecificHeader& operator=(UltrasonicDetectionSpecificHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UltrasonicDetectionSpecificHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UltrasonicDetectionSpecificHeader* internal_default_instance() {
    return reinterpret_cast<const UltrasonicDetectionSpecificHeader*>(
               &_UltrasonicDetectionSpecificHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(UltrasonicDetectionSpecificHeader* other);
  friend void swap(UltrasonicDetectionSpecificHeader& a, UltrasonicDetectionSpecificHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UltrasonicDetectionSpecificHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  UltrasonicDetectionSpecificHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UltrasonicDetectionSpecificHeader& from);
  void MergeFrom(const UltrasonicDetectionSpecificHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UltrasonicDetectionSpecificHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double max_range = 1;
  void clear_max_range();
  static const int kMaxRangeFieldNumber = 1;
  double max_range() const;
  void set_max_range(double value);

  // uint32 number_of_valid_indirect_detections = 2;
  void clear_number_of_valid_indirect_detections();
  static const int kNumberOfValidIndirectDetectionsFieldNumber = 2;
  ::google::protobuf::uint32 number_of_valid_indirect_detections() const;
  void set_number_of_valid_indirect_detections(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:osi3.UltrasonicDetectionSpecificHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double max_range_;
  ::google::protobuf::uint32 number_of_valid_indirect_detections_;
  mutable int _cached_size_;
  friend struct ::protobuf_osi_5ffeaturedata_2eproto::TableStruct;
  friend void ::protobuf_osi_5ffeaturedata_2eproto::InitDefaultsUltrasonicDetectionSpecificHeaderImpl();
};
// -------------------------------------------------------------------

class UltrasonicDetectionData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:osi3.UltrasonicDetectionData) */ {
 public:
  UltrasonicDetectionData();
  virtual ~UltrasonicDetectionData();

  UltrasonicDetectionData(const UltrasonicDetectionData& from);

  inline UltrasonicDetectionData& operator=(const UltrasonicDetectionData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UltrasonicDetectionData(UltrasonicDetectionData&& from) noexcept
    : UltrasonicDetectionData() {
    *this = ::std::move(from);
  }

  inline UltrasonicDetectionData& operator=(UltrasonicDetectionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UltrasonicDetectionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UltrasonicDetectionData* internal_default_instance() {
    return reinterpret_cast<const UltrasonicDetectionData*>(
               &_UltrasonicDetectionData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(UltrasonicDetectionData* other);
  friend void swap(UltrasonicDetectionData& a, UltrasonicDetectionData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UltrasonicDetectionData* New() const PROTOBUF_FINAL { return New(NULL); }

  UltrasonicDetectionData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UltrasonicDetectionData& from);
  void MergeFrom(const UltrasonicDetectionData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UltrasonicDetectionData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .osi3.UltrasonicDetection detection = 2;
  int detection_size() const;
  void clear_detection();
  static const int kDetectionFieldNumber = 2;
  const ::osi3::UltrasonicDetection& detection(int index) const;
  ::osi3::UltrasonicDetection* mutable_detection(int index);
  ::osi3::UltrasonicDetection* add_detection();
  ::google::protobuf::RepeatedPtrField< ::osi3::UltrasonicDetection >*
      mutable_detection();
  const ::google::protobuf::RepeatedPtrField< ::osi3::UltrasonicDetection >&
      detection() const;

  // repeated .osi3.UltrasonicIndirectDetection indirect_detection = 4;
  int indirect_detection_size() const;
  void clear_indirect_detection();
  static const int kIndirectDetectionFieldNumber = 4;
  const ::osi3::UltrasonicIndirectDetection& indirect_detection(int index) const;
  ::osi3::UltrasonicIndirectDetection* mutable_indirect_detection(int index);
  ::osi3::UltrasonicIndirectDetection* add_indirect_detection();
  ::google::protobuf::RepeatedPtrField< ::osi3::UltrasonicIndirectDetection >*
      mutable_indirect_detection();
  const ::google::protobuf::RepeatedPtrField< ::osi3::UltrasonicIndirectDetection >&
      indirect_detection() const;

  // .osi3.SensorDetectionHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::osi3::SensorDetectionHeader& header() const;
  ::osi3::SensorDetectionHeader* release_header();
  ::osi3::SensorDetectionHeader* mutable_header();
  void set_allocated_header(::osi3::SensorDetectionHeader* header);

  // .osi3.UltrasonicDetectionSpecificHeader specific_header = 3;
  bool has_specific_header() const;
  void clear_specific_header();
  static const int kSpecificHeaderFieldNumber = 3;
  const ::osi3::UltrasonicDetectionSpecificHeader& specific_header() const;
  ::osi3::UltrasonicDetectionSpecificHeader* release_specific_header();
  ::osi3::UltrasonicDetectionSpecificHeader* mutable_specific_header();
  void set_allocated_specific_header(::osi3::UltrasonicDetectionSpecificHeader* specific_header);

  // @@protoc_insertion_point(class_scope:osi3.UltrasonicDetectionData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::osi3::UltrasonicDetection > detection_;
  ::google::protobuf::RepeatedPtrField< ::osi3::UltrasonicIndirectDetection > indirect_detection_;
  ::osi3::SensorDetectionHeader* header_;
  ::osi3::UltrasonicDetectionSpecificHeader* specific_header_;
  mutable int _cached_size_;
  friend struct ::protobuf_osi_5ffeaturedata_2eproto::TableStruct;
  friend void ::protobuf_osi_5ffeaturedata_2eproto::InitDefaultsUltrasonicDetectionDataImpl();
};
// -------------------------------------------------------------------

class UltrasonicDetection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:osi3.UltrasonicDetection) */ {
 public:
  UltrasonicDetection();
  virtual ~UltrasonicDetection();

  UltrasonicDetection(const UltrasonicDetection& from);

  inline UltrasonicDetection& operator=(const UltrasonicDetection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UltrasonicDetection(UltrasonicDetection&& from) noexcept
    : UltrasonicDetection() {
    *this = ::std::move(from);
  }

  inline UltrasonicDetection& operator=(UltrasonicDetection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UltrasonicDetection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UltrasonicDetection* internal_default_instance() {
    return reinterpret_cast<const UltrasonicDetection*>(
               &_UltrasonicDetection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(UltrasonicDetection* other);
  friend void swap(UltrasonicDetection& a, UltrasonicDetection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UltrasonicDetection* New() const PROTOBUF_FINAL { return New(NULL); }

  UltrasonicDetection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UltrasonicDetection& from);
  void MergeFrom(const UltrasonicDetection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UltrasonicDetection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .osi3.Identifier object_id = 2;
  bool has_object_id() const;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 2;
  const ::osi3::Identifier& object_id() const;
  ::osi3::Identifier* release_object_id();
  ::osi3::Identifier* mutable_object_id();
  void set_allocated_object_id(::osi3::Identifier* object_id);

  // double existence_probability = 1;
  void clear_existence_probability();
  static const int kExistenceProbabilityFieldNumber = 1;
  double existence_probability() const;
  void set_existence_probability(double value);

  // double distance = 3;
  void clear_distance();
  static const int kDistanceFieldNumber = 3;
  double distance() const;
  void set_distance(double value);

  // @@protoc_insertion_point(class_scope:osi3.UltrasonicDetection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::osi3::Identifier* object_id_;
  double existence_probability_;
  double distance_;
  mutable int _cached_size_;
  friend struct ::protobuf_osi_5ffeaturedata_2eproto::TableStruct;
  friend void ::protobuf_osi_5ffeaturedata_2eproto::InitDefaultsUltrasonicDetectionImpl();
};
// -------------------------------------------------------------------

class UltrasonicIndirectDetection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:osi3.UltrasonicIndirectDetection) */ {
 public:
  UltrasonicIndirectDetection();
  virtual ~UltrasonicIndirectDetection();

  UltrasonicIndirectDetection(const UltrasonicIndirectDetection& from);

  inline UltrasonicIndirectDetection& operator=(const UltrasonicIndirectDetection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UltrasonicIndirectDetection(UltrasonicIndirectDetection&& from) noexcept
    : UltrasonicIndirectDetection() {
    *this = ::std::move(from);
  }

  inline UltrasonicIndirectDetection& operator=(UltrasonicIndirectDetection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UltrasonicIndirectDetection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UltrasonicIndirectDetection* internal_default_instance() {
    return reinterpret_cast<const UltrasonicIndirectDetection*>(
               &_UltrasonicIndirectDetection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(UltrasonicIndirectDetection* other);
  friend void swap(UltrasonicIndirectDetection& a, UltrasonicIndirectDetection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UltrasonicIndirectDetection* New() const PROTOBUF_FINAL { return New(NULL); }

  UltrasonicIndirectDetection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UltrasonicIndirectDetection& from);
  void MergeFrom(const UltrasonicIndirectDetection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UltrasonicIndirectDetection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .osi3.Identifier object_id = 2;
  bool has_object_id() const;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 2;
  const ::osi3::Identifier& object_id() const;
  ::osi3::Identifier* release_object_id();
  ::osi3::Identifier* mutable_object_id();
  void set_allocated_object_id(::osi3::Identifier* object_id);

  // .osi3.Identifier receiver_id = 5;
  bool has_receiver_id() const;
  void clear_receiver_id();
  static const int kReceiverIdFieldNumber = 5;
  const ::osi3::Identifier& receiver_id() const;
  ::osi3::Identifier* release_receiver_id();
  ::osi3::Identifier* mutable_receiver_id();
  void set_allocated_receiver_id(::osi3::Identifier* receiver_id);

  // .osi3.Vector3d receiver_origin = 6;
  bool has_receiver_origin() const;
  void clear_receiver_origin();
  static const int kReceiverOriginFieldNumber = 6;
  const ::osi3::Vector3d& receiver_origin() const;
  ::osi3::Vector3d* release_receiver_origin();
  ::osi3::Vector3d* mutable_receiver_origin();
  void set_allocated_receiver_origin(::osi3::Vector3d* receiver_origin);

  // double existence_probability = 1;
  void clear_existence_probability();
  static const int kExistenceProbabilityFieldNumber = 1;
  double existence_probability() const;
  void set_existence_probability(double value);

  // double ellipsoid_radial = 3;
  void clear_ellipsoid_radial();
  static const int kEllipsoidRadialFieldNumber = 3;
  double ellipsoid_radial() const;
  void set_ellipsoid_radial(double value);

  // double ellipsoid_axial = 4;
  void clear_ellipsoid_axial();
  static const int kEllipsoidAxialFieldNumber = 4;
  double ellipsoid_axial() const;
  void set_ellipsoid_axial(double value);

  // @@protoc_insertion_point(class_scope:osi3.UltrasonicIndirectDetection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::osi3::Identifier* object_id_;
  ::osi3::Identifier* receiver_id_;
  ::osi3::Vector3d* receiver_origin_;
  double existence_probability_;
  double ellipsoid_radial_;
  double ellipsoid_axial_;
  mutable int _cached_size_;
  friend struct ::protobuf_osi_5ffeaturedata_2eproto::TableStruct;
  friend void ::protobuf_osi_5ffeaturedata_2eproto::InitDefaultsUltrasonicIndirectDetectionImpl();
};
// -------------------------------------------------------------------

class CameraDetectionSpecificHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:osi3.CameraDetectionSpecificHeader) */ {
 public:
  CameraDetectionSpecificHeader();
  virtual ~CameraDetectionSpecificHeader();

  CameraDetectionSpecificHeader(const CameraDetectionSpecificHeader& from);

  inline CameraDetectionSpecificHeader& operator=(const CameraDetectionSpecificHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CameraDetectionSpecificHeader(CameraDetectionSpecificHeader&& from) noexcept
    : CameraDetectionSpecificHeader() {
    *this = ::std::move(from);
  }

  inline CameraDetectionSpecificHeader& operator=(CameraDetectionSpecificHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraDetectionSpecificHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraDetectionSpecificHeader* internal_default_instance() {
    return reinterpret_cast<const CameraDetectionSpecificHeader*>(
               &_CameraDetectionSpecificHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(CameraDetectionSpecificHeader* other);
  friend void swap(CameraDetectionSpecificHeader& a, CameraDetectionSpecificHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraDetectionSpecificHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  CameraDetectionSpecificHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CameraDetectionSpecificHeader& from);
  void MergeFrom(const CameraDetectionSpecificHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CameraDetectionSpecificHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 number_of_valid_points = 1;
  void clear_number_of_valid_points();
  static const int kNumberOfValidPointsFieldNumber = 1;
  ::google::protobuf::uint32 number_of_valid_points() const;
  void set_number_of_valid_points(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:osi3.CameraDetectionSpecificHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 number_of_valid_points_;
  mutable int _cached_size_;
  friend struct ::protobuf_osi_5ffeaturedata_2eproto::TableStruct;
  friend void ::protobuf_osi_5ffeaturedata_2eproto::InitDefaultsCameraDetectionSpecificHeaderImpl();
};
// -------------------------------------------------------------------

class CameraDetectionData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:osi3.CameraDetectionData) */ {
 public:
  CameraDetectionData();
  virtual ~CameraDetectionData();

  CameraDetectionData(const CameraDetectionData& from);

  inline CameraDetectionData& operator=(const CameraDetectionData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CameraDetectionData(CameraDetectionData&& from) noexcept
    : CameraDetectionData() {
    *this = ::std::move(from);
  }

  inline CameraDetectionData& operator=(CameraDetectionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraDetectionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraDetectionData* internal_default_instance() {
    return reinterpret_cast<const CameraDetectionData*>(
               &_CameraDetectionData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(CameraDetectionData* other);
  friend void swap(CameraDetectionData& a, CameraDetectionData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraDetectionData* New() const PROTOBUF_FINAL { return New(NULL); }

  CameraDetectionData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CameraDetectionData& from);
  void MergeFrom(const CameraDetectionData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CameraDetectionData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .osi3.CameraDetection detection = 2;
  int detection_size() const;
  void clear_detection();
  static const int kDetectionFieldNumber = 2;
  const ::osi3::CameraDetection& detection(int index) const;
  ::osi3::CameraDetection* mutable_detection(int index);
  ::osi3::CameraDetection* add_detection();
  ::google::protobuf::RepeatedPtrField< ::osi3::CameraDetection >*
      mutable_detection();
  const ::google::protobuf::RepeatedPtrField< ::osi3::CameraDetection >&
      detection() const;

  // repeated .osi3.CameraPoint point = 4;
  int point_size() const;
  void clear_point();
  static const int kPointFieldNumber = 4;
  const ::osi3::CameraPoint& point(int index) const;
  ::osi3::CameraPoint* mutable_point(int index);
  ::osi3::CameraPoint* add_point();
  ::google::protobuf::RepeatedPtrField< ::osi3::CameraPoint >*
      mutable_point();
  const ::google::protobuf::RepeatedPtrField< ::osi3::CameraPoint >&
      point() const;

  // .osi3.SensorDetectionHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::osi3::SensorDetectionHeader& header() const;
  ::osi3::SensorDetectionHeader* release_header();
  ::osi3::SensorDetectionHeader* mutable_header();
  void set_allocated_header(::osi3::SensorDetectionHeader* header);

  // .osi3.CameraDetectionSpecificHeader specific_header = 3;
  bool has_specific_header() const;
  void clear_specific_header();
  static const int kSpecificHeaderFieldNumber = 3;
  const ::osi3::CameraDetectionSpecificHeader& specific_header() const;
  ::osi3::CameraDetectionSpecificHeader* release_specific_header();
  ::osi3::CameraDetectionSpecificHeader* mutable_specific_header();
  void set_allocated_specific_header(::osi3::CameraDetectionSpecificHeader* specific_header);

  // @@protoc_insertion_point(class_scope:osi3.CameraDetectionData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::osi3::CameraDetection > detection_;
  ::google::protobuf::RepeatedPtrField< ::osi3::CameraPoint > point_;
  ::osi3::SensorDetectionHeader* header_;
  ::osi3::CameraDetectionSpecificHeader* specific_header_;
  mutable int _cached_size_;
  friend struct ::protobuf_osi_5ffeaturedata_2eproto::TableStruct;
  friend void ::protobuf_osi_5ffeaturedata_2eproto::InitDefaultsCameraDetectionDataImpl();
};
// -------------------------------------------------------------------

class CameraDetection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:osi3.CameraDetection) */ {
 public:
  CameraDetection();
  virtual ~CameraDetection();

  CameraDetection(const CameraDetection& from);

  inline CameraDetection& operator=(const CameraDetection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CameraDetection(CameraDetection&& from) noexcept
    : CameraDetection() {
    *this = ::std::move(from);
  }

  inline CameraDetection& operator=(CameraDetection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraDetection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraDetection* internal_default_instance() {
    return reinterpret_cast<const CameraDetection*>(
               &_CameraDetection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(CameraDetection* other);
  friend void swap(CameraDetection& a, CameraDetection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraDetection* New() const PROTOBUF_FINAL { return New(NULL); }

  CameraDetection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CameraDetection& from);
  void MergeFrom(const CameraDetection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CameraDetection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CameraDetection_Color Color;
  static const Color COLOR_UNKNOWN =
    CameraDetection_Color_COLOR_UNKNOWN;
  static const Color COLOR_OTHER =
    CameraDetection_Color_COLOR_OTHER;
  static const Color COLOR_BLACK =
    CameraDetection_Color_COLOR_BLACK;
  static const Color COLOR_GREY =
    CameraDetection_Color_COLOR_GREY;
  static const Color COLOR_WHITE =
    CameraDetection_Color_COLOR_WHITE;
  static const Color COLOR_YELLOW =
    CameraDetection_Color_COLOR_YELLOW;
  static const Color COLOR_ORANGE =
    CameraDetection_Color_COLOR_ORANGE;
  static const Color COLOR_RED =
    CameraDetection_Color_COLOR_RED;
  static const Color COLOR_VIOLET =
    CameraDetection_Color_COLOR_VIOLET;
  static const Color COLOR_BLUE =
    CameraDetection_Color_COLOR_BLUE;
  static const Color COLOR_GREEN =
    CameraDetection_Color_COLOR_GREEN;
  static const Color COLOR_REFLECTIVE =
    CameraDetection_Color_COLOR_REFLECTIVE;
  static inline bool Color_IsValid(int value) {
    return CameraDetection_Color_IsValid(value);
  }
  static const Color Color_MIN =
    CameraDetection_Color_Color_MIN;
  static const Color Color_MAX =
    CameraDetection_Color_Color_MAX;
  static const int Color_ARRAYSIZE =
    CameraDetection_Color_Color_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Color_descriptor() {
    return CameraDetection_Color_descriptor();
  }
  static inline const ::std::string& Color_Name(Color value) {
    return CameraDetection_Color_Name(value);
  }
  static inline bool Color_Parse(const ::std::string& name,
      Color* value) {
    return CameraDetection_Color_Parse(name, value);
  }

  typedef CameraDetection_ImageShapeType ImageShapeType;
  static const ImageShapeType IMAGE_SHAPE_TYPE_UNKNOWN =
    CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_UNKNOWN;
  static const ImageShapeType IMAGE_SHAPE_TYPE_OTHER =
    CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_OTHER;
  static const ImageShapeType IMAGE_SHAPE_TYPE_POINT =
    CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POINT;
  static const ImageShapeType IMAGE_SHAPE_TYPE_BOX =
    CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_BOX;
  static const ImageShapeType IMAGE_SHAPE_TYPE_ELLIPSE =
    CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_ELLIPSE;
  static const ImageShapeType IMAGE_SHAPE_TYPE_POLYGON =
    CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POLYGON;
  static const ImageShapeType IMAGE_SHAPE_TYPE_POLYLINE =
    CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POLYLINE;
  static const ImageShapeType IMAGE_SHAPE_TYPE_POINT_CLOUD =
    CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POINT_CLOUD;
  static inline bool ImageShapeType_IsValid(int value) {
    return CameraDetection_ImageShapeType_IsValid(value);
  }
  static const ImageShapeType ImageShapeType_MIN =
    CameraDetection_ImageShapeType_ImageShapeType_MIN;
  static const ImageShapeType ImageShapeType_MAX =
    CameraDetection_ImageShapeType_ImageShapeType_MAX;
  static const int ImageShapeType_ARRAYSIZE =
    CameraDetection_ImageShapeType_ImageShapeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ImageShapeType_descriptor() {
    return CameraDetection_ImageShapeType_descriptor();
  }
  static inline const ::std::string& ImageShapeType_Name(ImageShapeType value) {
    return CameraDetection_ImageShapeType_Name(value);
  }
  static inline bool ImageShapeType_Parse(const ::std::string& name,
      ImageShapeType* value) {
    return CameraDetection_ImageShapeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .osi3.Identifier object_id = 2;
  bool has_object_id() const;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 2;
  const ::osi3::Identifier& object_id() const;
  ::osi3::Identifier* release_object_id();
  ::osi3::Identifier* mutable_object_id();
  void set_allocated_object_id(::osi3::Identifier* object_id);

  // .osi3.Timestamp time_difference = 3;
  bool has_time_difference() const;
  void clear_time_difference();
  static const int kTimeDifferenceFieldNumber = 3;
  const ::osi3::Timestamp& time_difference() const;
  ::osi3::Timestamp* release_time_difference();
  ::osi3::Timestamp* mutable_time_difference();
  void set_allocated_time_difference(::osi3::Timestamp* time_difference);

  // .osi3.Identifier ambiguity_id = 30;
  bool has_ambiguity_id() const;
  void clear_ambiguity_id();
  static const int kAmbiguityIdFieldNumber = 30;
  const ::osi3::Identifier& ambiguity_id() const;
  ::osi3::Identifier* release_ambiguity_id();
  ::osi3::Identifier* mutable_ambiguity_id();
  void set_allocated_ambiguity_id(::osi3::Identifier* ambiguity_id);

  // double existence_probability = 1;
  void clear_existence_probability();
  static const int kExistenceProbabilityFieldNumber = 1;
  double existence_probability() const;
  void set_existence_probability(double value);

  // .osi3.CameraDetection.ImageShapeType image_shape_type = 4;
  void clear_image_shape_type();
  static const int kImageShapeTypeFieldNumber = 4;
  ::osi3::CameraDetection_ImageShapeType image_shape_type() const;
  void set_image_shape_type(::osi3::CameraDetection_ImageShapeType value);

  // bool shape_classification_background = 5;
  void clear_shape_classification_background();
  static const int kShapeClassificationBackgroundFieldNumber = 5;
  bool shape_classification_background() const;
  void set_shape_classification_background(bool value);

  // bool shape_classification_foreground = 6;
  void clear_shape_classification_foreground();
  static const int kShapeClassificationForegroundFieldNumber = 6;
  bool shape_classification_foreground() const;
  void set_shape_classification_foreground(bool value);

  // bool shape_classification_flat = 7;
  void clear_shape_classification_flat();
  static const int kShapeClassificationFlatFieldNumber = 7;
  bool shape_classification_flat() const;
  void set_shape_classification_flat(bool value);

  // bool shape_classification_upright = 8;
  void clear_shape_classification_upright();
  static const int kShapeClassificationUprightFieldNumber = 8;
  bool shape_classification_upright() const;
  void set_shape_classification_upright(bool value);

  // bool shape_classification_ground = 9;
  void clear_shape_classification_ground();
  static const int kShapeClassificationGroundFieldNumber = 9;
  bool shape_classification_ground() const;
  void set_shape_classification_ground(bool value);

  // bool shape_classification_sky = 10;
  void clear_shape_classification_sky();
  static const int kShapeClassificationSkyFieldNumber = 10;
  bool shape_classification_sky() const;
  void set_shape_classification_sky(bool value);

  // bool shape_classification_vegetation = 11;
  void clear_shape_classification_vegetation();
  static const int kShapeClassificationVegetationFieldNumber = 11;
  bool shape_classification_vegetation() const;
  void set_shape_classification_vegetation(bool value);

  // bool shape_classification_road = 12;
  void clear_shape_classification_road();
  static const int kShapeClassificationRoadFieldNumber = 12;
  bool shape_classification_road() const;
  void set_shape_classification_road(bool value);

  // bool shape_classification_non_driving_lane = 13;
  void clear_shape_classification_non_driving_lane();
  static const int kShapeClassificationNonDrivingLaneFieldNumber = 13;
  bool shape_classification_non_driving_lane() const;
  void set_shape_classification_non_driving_lane(bool value);

  // bool shape_classification_non_road = 14;
  void clear_shape_classification_non_road();
  static const int kShapeClassificationNonRoadFieldNumber = 14;
  bool shape_classification_non_road() const;
  void set_shape_classification_non_road(bool value);

  // bool shape_classification_stationary_object = 15;
  void clear_shape_classification_stationary_object();
  static const int kShapeClassificationStationaryObjectFieldNumber = 15;
  bool shape_classification_stationary_object() const;
  void set_shape_classification_stationary_object(bool value);

  // bool shape_classification_moving_object = 16;
  void clear_shape_classification_moving_object();
  static const int kShapeClassificationMovingObjectFieldNumber = 16;
  bool shape_classification_moving_object() const;
  void set_shape_classification_moving_object(bool value);

  // bool shape_classification_landmark = 17;
  void clear_shape_classification_landmark();
  static const int kShapeClassificationLandmarkFieldNumber = 17;
  bool shape_classification_landmark() const;
  void set_shape_classification_landmark(bool value);

  // bool shape_classification_traffic_sign = 18;
  void clear_shape_classification_traffic_sign();
  static const int kShapeClassificationTrafficSignFieldNumber = 18;
  bool shape_classification_traffic_sign() const;
  void set_shape_classification_traffic_sign(bool value);

  // bool shape_classification_traffic_light = 19;
  void clear_shape_classification_traffic_light();
  static const int kShapeClassificationTrafficLightFieldNumber = 19;
  bool shape_classification_traffic_light() const;
  void set_shape_classification_traffic_light(bool value);

  // bool shape_classification_road_marking = 20;
  void clear_shape_classification_road_marking();
  static const int kShapeClassificationRoadMarkingFieldNumber = 20;
  bool shape_classification_road_marking() const;
  void set_shape_classification_road_marking(bool value);

  // bool shape_classification_vehicle = 21;
  void clear_shape_classification_vehicle();
  static const int kShapeClassificationVehicleFieldNumber = 21;
  bool shape_classification_vehicle() const;
  void set_shape_classification_vehicle(bool value);

  // bool shape_classification_pedestrian = 22;
  void clear_shape_classification_pedestrian();
  static const int kShapeClassificationPedestrianFieldNumber = 22;
  bool shape_classification_pedestrian() const;
  void set_shape_classification_pedestrian(bool value);

  // bool shape_classification_animal = 23;
  void clear_shape_classification_animal();
  static const int kShapeClassificationAnimalFieldNumber = 23;
  bool shape_classification_animal() const;
  void set_shape_classification_animal(bool value);

  // bool shape_classification_pedestrian_front = 24;
  void clear_shape_classification_pedestrian_front();
  static const int kShapeClassificationPedestrianFrontFieldNumber = 24;
  bool shape_classification_pedestrian_front() const;
  void set_shape_classification_pedestrian_front(bool value);

  // bool shape_classification_pedestrian_side = 25;
  void clear_shape_classification_pedestrian_side();
  static const int kShapeClassificationPedestrianSideFieldNumber = 25;
  bool shape_classification_pedestrian_side() const;
  void set_shape_classification_pedestrian_side(bool value);

  // bool shape_classification_pedestrian_rear = 26;
  void clear_shape_classification_pedestrian_rear();
  static const int kShapeClassificationPedestrianRearFieldNumber = 26;
  bool shape_classification_pedestrian_rear() const;
  void set_shape_classification_pedestrian_rear(bool value);

  // .osi3.CameraDetection.Color color = 28;
  void clear_color();
  static const int kColorFieldNumber = 28;
  ::osi3::CameraDetection_Color color() const;
  void set_color(::osi3::CameraDetection_Color value);

  // double shape_classification_probability = 27;
  void clear_shape_classification_probability();
  static const int kShapeClassificationProbabilityFieldNumber = 27;
  double shape_classification_probability() const;
  void set_shape_classification_probability(double value);

  // double color_probability = 29;
  void clear_color_probability();
  static const int kColorProbabilityFieldNumber = 29;
  double color_probability() const;
  void set_color_probability(double value);

  // uint32 first_point_index = 31;
  void clear_first_point_index();
  static const int kFirstPointIndexFieldNumber = 31;
  ::google::protobuf::uint32 first_point_index() const;
  void set_first_point_index(::google::protobuf::uint32 value);

  // uint32 number_of_points = 32;
  void clear_number_of_points();
  static const int kNumberOfPointsFieldNumber = 32;
  ::google::protobuf::uint32 number_of_points() const;
  void set_number_of_points(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:osi3.CameraDetection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::osi3::Identifier* object_id_;
  ::osi3::Timestamp* time_difference_;
  ::osi3::Identifier* ambiguity_id_;
  double existence_probability_;
  int image_shape_type_;
  bool shape_classification_background_;
  bool shape_classification_foreground_;
  bool shape_classification_flat_;
  bool shape_classification_upright_;
  bool shape_classification_ground_;
  bool shape_classification_sky_;
  bool shape_classification_vegetation_;
  bool shape_classification_road_;
  bool shape_classification_non_driving_lane_;
  bool shape_classification_non_road_;
  bool shape_classification_stationary_object_;
  bool shape_classification_moving_object_;
  bool shape_classification_landmark_;
  bool shape_classification_traffic_sign_;
  bool shape_classification_traffic_light_;
  bool shape_classification_road_marking_;
  bool shape_classification_vehicle_;
  bool shape_classification_pedestrian_;
  bool shape_classification_animal_;
  bool shape_classification_pedestrian_front_;
  bool shape_classification_pedestrian_side_;
  bool shape_classification_pedestrian_rear_;
  int color_;
  double shape_classification_probability_;
  double color_probability_;
  ::google::protobuf::uint32 first_point_index_;
  ::google::protobuf::uint32 number_of_points_;
  mutable int _cached_size_;
  friend struct ::protobuf_osi_5ffeaturedata_2eproto::TableStruct;
  friend void ::protobuf_osi_5ffeaturedata_2eproto::InitDefaultsCameraDetectionImpl();
};
// -------------------------------------------------------------------

class CameraPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:osi3.CameraPoint) */ {
 public:
  CameraPoint();
  virtual ~CameraPoint();

  CameraPoint(const CameraPoint& from);

  inline CameraPoint& operator=(const CameraPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CameraPoint(CameraPoint&& from) noexcept
    : CameraPoint() {
    *this = ::std::move(from);
  }

  inline CameraPoint& operator=(CameraPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraPoint* internal_default_instance() {
    return reinterpret_cast<const CameraPoint*>(
               &_CameraPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(CameraPoint* other);
  friend void swap(CameraPoint& a, CameraPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  CameraPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CameraPoint& from);
  void MergeFrom(const CameraPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CameraPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .osi3.Spherical3d point = 2;
  bool has_point() const;
  void clear_point();
  static const int kPointFieldNumber = 2;
  const ::osi3::Spherical3d& point() const;
  ::osi3::Spherical3d* release_point();
  ::osi3::Spherical3d* mutable_point();
  void set_allocated_point(::osi3::Spherical3d* point);

  // .osi3.Spherical3d point_rmse = 3;
  bool has_point_rmse() const;
  void clear_point_rmse();
  static const int kPointRmseFieldNumber = 3;
  const ::osi3::Spherical3d& point_rmse() const;
  ::osi3::Spherical3d* release_point_rmse();
  ::osi3::Spherical3d* mutable_point_rmse();
  void set_allocated_point_rmse(::osi3::Spherical3d* point_rmse);

  // double existence_probability = 1;
  void clear_existence_probability();
  static const int kExistenceProbabilityFieldNumber = 1;
  double existence_probability() const;
  void set_existence_probability(double value);

  // @@protoc_insertion_point(class_scope:osi3.CameraPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::osi3::Spherical3d* point_;
  ::osi3::Spherical3d* point_rmse_;
  double existence_probability_;
  mutable int _cached_size_;
  friend struct ::protobuf_osi_5ffeaturedata_2eproto::TableStruct;
  friend void ::protobuf_osi_5ffeaturedata_2eproto::InitDefaultsCameraPointImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FeatureData

// .osi3.InterfaceVersion version = 1;
inline bool FeatureData::has_version() const {
  return this != internal_default_instance() && version_ != NULL;
}
inline const ::osi3::InterfaceVersion& FeatureData::version() const {
  const ::osi3::InterfaceVersion* p = version_;
  // @@protoc_insertion_point(field_get:osi3.FeatureData.version)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::InterfaceVersion*>(
      &::osi3::_InterfaceVersion_default_instance_);
}
inline ::osi3::InterfaceVersion* FeatureData::release_version() {
  // @@protoc_insertion_point(field_release:osi3.FeatureData.version)
  
  ::osi3::InterfaceVersion* temp = version_;
  version_ = NULL;
  return temp;
}
inline ::osi3::InterfaceVersion* FeatureData::mutable_version() {
  
  if (version_ == NULL) {
    version_ = new ::osi3::InterfaceVersion;
  }
  // @@protoc_insertion_point(field_mutable:osi3.FeatureData.version)
  return version_;
}
inline void FeatureData::set_allocated_version(::osi3::InterfaceVersion* version) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(version_);
  }
  if (version) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      version = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:osi3.FeatureData.version)
}

// repeated .osi3.RadarDetectionData radar_sensor = 2;
inline int FeatureData::radar_sensor_size() const {
  return radar_sensor_.size();
}
inline void FeatureData::clear_radar_sensor() {
  radar_sensor_.Clear();
}
inline const ::osi3::RadarDetectionData& FeatureData::radar_sensor(int index) const {
  // @@protoc_insertion_point(field_get:osi3.FeatureData.radar_sensor)
  return radar_sensor_.Get(index);
}
inline ::osi3::RadarDetectionData* FeatureData::mutable_radar_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.FeatureData.radar_sensor)
  return radar_sensor_.Mutable(index);
}
inline ::osi3::RadarDetectionData* FeatureData::add_radar_sensor() {
  // @@protoc_insertion_point(field_add:osi3.FeatureData.radar_sensor)
  return radar_sensor_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::osi3::RadarDetectionData >*
FeatureData::mutable_radar_sensor() {
  // @@protoc_insertion_point(field_mutable_list:osi3.FeatureData.radar_sensor)
  return &radar_sensor_;
}
inline const ::google::protobuf::RepeatedPtrField< ::osi3::RadarDetectionData >&
FeatureData::radar_sensor() const {
  // @@protoc_insertion_point(field_list:osi3.FeatureData.radar_sensor)
  return radar_sensor_;
}

// repeated .osi3.LidarDetectionData lidar_sensor = 3;
inline int FeatureData::lidar_sensor_size() const {
  return lidar_sensor_.size();
}
inline void FeatureData::clear_lidar_sensor() {
  lidar_sensor_.Clear();
}
inline const ::osi3::LidarDetectionData& FeatureData::lidar_sensor(int index) const {
  // @@protoc_insertion_point(field_get:osi3.FeatureData.lidar_sensor)
  return lidar_sensor_.Get(index);
}
inline ::osi3::LidarDetectionData* FeatureData::mutable_lidar_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.FeatureData.lidar_sensor)
  return lidar_sensor_.Mutable(index);
}
inline ::osi3::LidarDetectionData* FeatureData::add_lidar_sensor() {
  // @@protoc_insertion_point(field_add:osi3.FeatureData.lidar_sensor)
  return lidar_sensor_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::osi3::LidarDetectionData >*
FeatureData::mutable_lidar_sensor() {
  // @@protoc_insertion_point(field_mutable_list:osi3.FeatureData.lidar_sensor)
  return &lidar_sensor_;
}
inline const ::google::protobuf::RepeatedPtrField< ::osi3::LidarDetectionData >&
FeatureData::lidar_sensor() const {
  // @@protoc_insertion_point(field_list:osi3.FeatureData.lidar_sensor)
  return lidar_sensor_;
}

// repeated .osi3.UltrasonicDetectionData ultrasonic_sensor = 4;
inline int FeatureData::ultrasonic_sensor_size() const {
  return ultrasonic_sensor_.size();
}
inline void FeatureData::clear_ultrasonic_sensor() {
  ultrasonic_sensor_.Clear();
}
inline const ::osi3::UltrasonicDetectionData& FeatureData::ultrasonic_sensor(int index) const {
  // @@protoc_insertion_point(field_get:osi3.FeatureData.ultrasonic_sensor)
  return ultrasonic_sensor_.Get(index);
}
inline ::osi3::UltrasonicDetectionData* FeatureData::mutable_ultrasonic_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.FeatureData.ultrasonic_sensor)
  return ultrasonic_sensor_.Mutable(index);
}
inline ::osi3::UltrasonicDetectionData* FeatureData::add_ultrasonic_sensor() {
  // @@protoc_insertion_point(field_add:osi3.FeatureData.ultrasonic_sensor)
  return ultrasonic_sensor_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::osi3::UltrasonicDetectionData >*
FeatureData::mutable_ultrasonic_sensor() {
  // @@protoc_insertion_point(field_mutable_list:osi3.FeatureData.ultrasonic_sensor)
  return &ultrasonic_sensor_;
}
inline const ::google::protobuf::RepeatedPtrField< ::osi3::UltrasonicDetectionData >&
FeatureData::ultrasonic_sensor() const {
  // @@protoc_insertion_point(field_list:osi3.FeatureData.ultrasonic_sensor)
  return ultrasonic_sensor_;
}

// repeated .osi3.CameraDetectionData camera_sensor = 5;
inline int FeatureData::camera_sensor_size() const {
  return camera_sensor_.size();
}
inline void FeatureData::clear_camera_sensor() {
  camera_sensor_.Clear();
}
inline const ::osi3::CameraDetectionData& FeatureData::camera_sensor(int index) const {
  // @@protoc_insertion_point(field_get:osi3.FeatureData.camera_sensor)
  return camera_sensor_.Get(index);
}
inline ::osi3::CameraDetectionData* FeatureData::mutable_camera_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.FeatureData.camera_sensor)
  return camera_sensor_.Mutable(index);
}
inline ::osi3::CameraDetectionData* FeatureData::add_camera_sensor() {
  // @@protoc_insertion_point(field_add:osi3.FeatureData.camera_sensor)
  return camera_sensor_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::osi3::CameraDetectionData >*
FeatureData::mutable_camera_sensor() {
  // @@protoc_insertion_point(field_mutable_list:osi3.FeatureData.camera_sensor)
  return &camera_sensor_;
}
inline const ::google::protobuf::RepeatedPtrField< ::osi3::CameraDetectionData >&
FeatureData::camera_sensor() const {
  // @@protoc_insertion_point(field_list:osi3.FeatureData.camera_sensor)
  return camera_sensor_;
}

// -------------------------------------------------------------------

// SensorDetectionHeader

// .osi3.Timestamp measurement_time = 1;
inline bool SensorDetectionHeader::has_measurement_time() const {
  return this != internal_default_instance() && measurement_time_ != NULL;
}
inline const ::osi3::Timestamp& SensorDetectionHeader::measurement_time() const {
  const ::osi3::Timestamp* p = measurement_time_;
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.measurement_time)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::Timestamp*>(
      &::osi3::_Timestamp_default_instance_);
}
inline ::osi3::Timestamp* SensorDetectionHeader::release_measurement_time() {
  // @@protoc_insertion_point(field_release:osi3.SensorDetectionHeader.measurement_time)
  
  ::osi3::Timestamp* temp = measurement_time_;
  measurement_time_ = NULL;
  return temp;
}
inline ::osi3::Timestamp* SensorDetectionHeader::mutable_measurement_time() {
  
  if (measurement_time_ == NULL) {
    measurement_time_ = new ::osi3::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:osi3.SensorDetectionHeader.measurement_time)
  return measurement_time_;
}
inline void SensorDetectionHeader::set_allocated_measurement_time(::osi3::Timestamp* measurement_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(measurement_time_);
  }
  if (measurement_time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      measurement_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, measurement_time, submessage_arena);
    }
    
  } else {
    
  }
  measurement_time_ = measurement_time;
  // @@protoc_insertion_point(field_set_allocated:osi3.SensorDetectionHeader.measurement_time)
}

// uint64 cycle_counter = 2;
inline void SensorDetectionHeader::clear_cycle_counter() {
  cycle_counter_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SensorDetectionHeader::cycle_counter() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.cycle_counter)
  return cycle_counter_;
}
inline void SensorDetectionHeader::set_cycle_counter(::google::protobuf::uint64 value) {
  
  cycle_counter_ = value;
  // @@protoc_insertion_point(field_set:osi3.SensorDetectionHeader.cycle_counter)
}

// .osi3.MountingPosition mounting_position = 3;
inline bool SensorDetectionHeader::has_mounting_position() const {
  return this != internal_default_instance() && mounting_position_ != NULL;
}
inline const ::osi3::MountingPosition& SensorDetectionHeader::mounting_position() const {
  const ::osi3::MountingPosition* p = mounting_position_;
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.mounting_position)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::MountingPosition*>(
      &::osi3::_MountingPosition_default_instance_);
}
inline ::osi3::MountingPosition* SensorDetectionHeader::release_mounting_position() {
  // @@protoc_insertion_point(field_release:osi3.SensorDetectionHeader.mounting_position)
  
  ::osi3::MountingPosition* temp = mounting_position_;
  mounting_position_ = NULL;
  return temp;
}
inline ::osi3::MountingPosition* SensorDetectionHeader::mutable_mounting_position() {
  
  if (mounting_position_ == NULL) {
    mounting_position_ = new ::osi3::MountingPosition;
  }
  // @@protoc_insertion_point(field_mutable:osi3.SensorDetectionHeader.mounting_position)
  return mounting_position_;
}
inline void SensorDetectionHeader::set_allocated_mounting_position(::osi3::MountingPosition* mounting_position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(mounting_position_);
  }
  if (mounting_position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mounting_position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mounting_position, submessage_arena);
    }
    
  } else {
    
  }
  mounting_position_ = mounting_position;
  // @@protoc_insertion_point(field_set_allocated:osi3.SensorDetectionHeader.mounting_position)
}

// .osi3.MountingPosition mounting_position_rmse = 4;
inline bool SensorDetectionHeader::has_mounting_position_rmse() const {
  return this != internal_default_instance() && mounting_position_rmse_ != NULL;
}
inline const ::osi3::MountingPosition& SensorDetectionHeader::mounting_position_rmse() const {
  const ::osi3::MountingPosition* p = mounting_position_rmse_;
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.mounting_position_rmse)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::MountingPosition*>(
      &::osi3::_MountingPosition_default_instance_);
}
inline ::osi3::MountingPosition* SensorDetectionHeader::release_mounting_position_rmse() {
  // @@protoc_insertion_point(field_release:osi3.SensorDetectionHeader.mounting_position_rmse)
  
  ::osi3::MountingPosition* temp = mounting_position_rmse_;
  mounting_position_rmse_ = NULL;
  return temp;
}
inline ::osi3::MountingPosition* SensorDetectionHeader::mutable_mounting_position_rmse() {
  
  if (mounting_position_rmse_ == NULL) {
    mounting_position_rmse_ = new ::osi3::MountingPosition;
  }
  // @@protoc_insertion_point(field_mutable:osi3.SensorDetectionHeader.mounting_position_rmse)
  return mounting_position_rmse_;
}
inline void SensorDetectionHeader::set_allocated_mounting_position_rmse(::osi3::MountingPosition* mounting_position_rmse) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(mounting_position_rmse_);
  }
  if (mounting_position_rmse) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mounting_position_rmse = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mounting_position_rmse, submessage_arena);
    }
    
  } else {
    
  }
  mounting_position_rmse_ = mounting_position_rmse;
  // @@protoc_insertion_point(field_set_allocated:osi3.SensorDetectionHeader.mounting_position_rmse)
}

// .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
inline void SensorDetectionHeader::clear_data_qualifier() {
  data_qualifier_ = 0;
}
inline ::osi3::SensorDetectionHeader_DataQualifier SensorDetectionHeader::data_qualifier() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.data_qualifier)
  return static_cast< ::osi3::SensorDetectionHeader_DataQualifier >(data_qualifier_);
}
inline void SensorDetectionHeader::set_data_qualifier(::osi3::SensorDetectionHeader_DataQualifier value) {
  
  data_qualifier_ = value;
  // @@protoc_insertion_point(field_set:osi3.SensorDetectionHeader.data_qualifier)
}

// uint32 number_of_valid_detections = 6;
inline void SensorDetectionHeader::clear_number_of_valid_detections() {
  number_of_valid_detections_ = 0u;
}
inline ::google::protobuf::uint32 SensorDetectionHeader::number_of_valid_detections() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.number_of_valid_detections)
  return number_of_valid_detections_;
}
inline void SensorDetectionHeader::set_number_of_valid_detections(::google::protobuf::uint32 value) {
  
  number_of_valid_detections_ = value;
  // @@protoc_insertion_point(field_set:osi3.SensorDetectionHeader.number_of_valid_detections)
}

// .osi3.Identifier sensor_id = 7;
inline bool SensorDetectionHeader::has_sensor_id() const {
  return this != internal_default_instance() && sensor_id_ != NULL;
}
inline const ::osi3::Identifier& SensorDetectionHeader::sensor_id() const {
  const ::osi3::Identifier* p = sensor_id_;
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.sensor_id)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline ::osi3::Identifier* SensorDetectionHeader::release_sensor_id() {
  // @@protoc_insertion_point(field_release:osi3.SensorDetectionHeader.sensor_id)
  
  ::osi3::Identifier* temp = sensor_id_;
  sensor_id_ = NULL;
  return temp;
}
inline ::osi3::Identifier* SensorDetectionHeader::mutable_sensor_id() {
  
  if (sensor_id_ == NULL) {
    sensor_id_ = new ::osi3::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:osi3.SensorDetectionHeader.sensor_id)
  return sensor_id_;
}
inline void SensorDetectionHeader::set_allocated_sensor_id(::osi3::Identifier* sensor_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(sensor_id_);
  }
  if (sensor_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sensor_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sensor_id, submessage_arena);
    }
    
  } else {
    
  }
  sensor_id_ = sensor_id;
  // @@protoc_insertion_point(field_set_allocated:osi3.SensorDetectionHeader.sensor_id)
}

// .osi3.SensorDetectionHeader.ExtendedQualifier extended_qualifier = 8;
inline void SensorDetectionHeader::clear_extended_qualifier() {
  extended_qualifier_ = 0;
}
inline ::osi3::SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::extended_qualifier() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.extended_qualifier)
  return static_cast< ::osi3::SensorDetectionHeader_ExtendedQualifier >(extended_qualifier_);
}
inline void SensorDetectionHeader::set_extended_qualifier(::osi3::SensorDetectionHeader_ExtendedQualifier value) {
  
  extended_qualifier_ = value;
  // @@protoc_insertion_point(field_set:osi3.SensorDetectionHeader.extended_qualifier)
}

// -------------------------------------------------------------------

// RadarDetectionData

// .osi3.SensorDetectionHeader header = 1;
inline bool RadarDetectionData::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RadarDetectionData::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::osi3::SensorDetectionHeader& RadarDetectionData::header() const {
  const ::osi3::SensorDetectionHeader* p = header_;
  // @@protoc_insertion_point(field_get:osi3.RadarDetectionData.header)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::SensorDetectionHeader*>(
      &::osi3::_SensorDetectionHeader_default_instance_);
}
inline ::osi3::SensorDetectionHeader* RadarDetectionData::release_header() {
  // @@protoc_insertion_point(field_release:osi3.RadarDetectionData.header)
  
  ::osi3::SensorDetectionHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::osi3::SensorDetectionHeader* RadarDetectionData::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::osi3::SensorDetectionHeader;
  }
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetectionData.header)
  return header_;
}
inline void RadarDetectionData::set_allocated_header(::osi3::SensorDetectionHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetectionData.header)
}

// repeated .osi3.RadarDetection detection = 2;
inline int RadarDetectionData::detection_size() const {
  return detection_.size();
}
inline void RadarDetectionData::clear_detection() {
  detection_.Clear();
}
inline const ::osi3::RadarDetection& RadarDetectionData::detection(int index) const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetectionData.detection)
  return detection_.Get(index);
}
inline ::osi3::RadarDetection* RadarDetectionData::mutable_detection(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetectionData.detection)
  return detection_.Mutable(index);
}
inline ::osi3::RadarDetection* RadarDetectionData::add_detection() {
  // @@protoc_insertion_point(field_add:osi3.RadarDetectionData.detection)
  return detection_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::osi3::RadarDetection >*
RadarDetectionData::mutable_detection() {
  // @@protoc_insertion_point(field_mutable_list:osi3.RadarDetectionData.detection)
  return &detection_;
}
inline const ::google::protobuf::RepeatedPtrField< ::osi3::RadarDetection >&
RadarDetectionData::detection() const {
  // @@protoc_insertion_point(field_list:osi3.RadarDetectionData.detection)
  return detection_;
}

// -------------------------------------------------------------------

// RadarDetection

// double existence_probability = 1;
inline void RadarDetection::clear_existence_probability() {
  existence_probability_ = 0;
}
inline double RadarDetection::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.existence_probability)
  return existence_probability_;
}
inline void RadarDetection::set_existence_probability(double value) {
  
  existence_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.existence_probability)
}

// .osi3.Identifier object_id = 2;
inline bool RadarDetection::has_object_id() const {
  return this != internal_default_instance() && object_id_ != NULL;
}
inline const ::osi3::Identifier& RadarDetection::object_id() const {
  const ::osi3::Identifier* p = object_id_;
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.object_id)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline ::osi3::Identifier* RadarDetection::release_object_id() {
  // @@protoc_insertion_point(field_release:osi3.RadarDetection.object_id)
  
  ::osi3::Identifier* temp = object_id_;
  object_id_ = NULL;
  return temp;
}
inline ::osi3::Identifier* RadarDetection::mutable_object_id() {
  
  if (object_id_ == NULL) {
    object_id_ = new ::osi3::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetection.object_id)
  return object_id_;
}
inline void RadarDetection::set_allocated_object_id(::osi3::Identifier* object_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(object_id_);
  }
  if (object_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      object_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, object_id, submessage_arena);
    }
    
  } else {
    
  }
  object_id_ = object_id;
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetection.object_id)
}

// .osi3.Spherical3d position = 3;
inline bool RadarDetection::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline const ::osi3::Spherical3d& RadarDetection::position() const {
  const ::osi3::Spherical3d* p = position_;
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.position)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::Spherical3d*>(
      &::osi3::_Spherical3d_default_instance_);
}
inline ::osi3::Spherical3d* RadarDetection::release_position() {
  // @@protoc_insertion_point(field_release:osi3.RadarDetection.position)
  
  ::osi3::Spherical3d* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::osi3::Spherical3d* RadarDetection::mutable_position() {
  
  if (position_ == NULL) {
    position_ = new ::osi3::Spherical3d;
  }
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetection.position)
  return position_;
}
inline void RadarDetection::set_allocated_position(::osi3::Spherical3d* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_);
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetection.position)
}

// .osi3.Spherical3d position_rmse = 4;
inline bool RadarDetection::has_position_rmse() const {
  return this != internal_default_instance() && position_rmse_ != NULL;
}
inline const ::osi3::Spherical3d& RadarDetection::position_rmse() const {
  const ::osi3::Spherical3d* p = position_rmse_;
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.position_rmse)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::Spherical3d*>(
      &::osi3::_Spherical3d_default_instance_);
}
inline ::osi3::Spherical3d* RadarDetection::release_position_rmse() {
  // @@protoc_insertion_point(field_release:osi3.RadarDetection.position_rmse)
  
  ::osi3::Spherical3d* temp = position_rmse_;
  position_rmse_ = NULL;
  return temp;
}
inline ::osi3::Spherical3d* RadarDetection::mutable_position_rmse() {
  
  if (position_rmse_ == NULL) {
    position_rmse_ = new ::osi3::Spherical3d;
  }
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetection.position_rmse)
  return position_rmse_;
}
inline void RadarDetection::set_allocated_position_rmse(::osi3::Spherical3d* position_rmse) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_rmse_);
  }
  if (position_rmse) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position_rmse = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position_rmse, submessage_arena);
    }
    
  } else {
    
  }
  position_rmse_ = position_rmse;
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetection.position_rmse)
}

// double radial_velocity = 5;
inline void RadarDetection::clear_radial_velocity() {
  radial_velocity_ = 0;
}
inline double RadarDetection::radial_velocity() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.radial_velocity)
  return radial_velocity_;
}
inline void RadarDetection::set_radial_velocity(double value) {
  
  radial_velocity_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.radial_velocity)
}

// double radial_velocity_rmse = 6;
inline void RadarDetection::clear_radial_velocity_rmse() {
  radial_velocity_rmse_ = 0;
}
inline double RadarDetection::radial_velocity_rmse() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.radial_velocity_rmse)
  return radial_velocity_rmse_;
}
inline void RadarDetection::set_radial_velocity_rmse(double value) {
  
  radial_velocity_rmse_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.radial_velocity_rmse)
}

// double rcs = 7;
inline void RadarDetection::clear_rcs() {
  rcs_ = 0;
}
inline double RadarDetection::rcs() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.rcs)
  return rcs_;
}
inline void RadarDetection::set_rcs(double value) {
  
  rcs_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.rcs)
}

// double snr = 8;
inline void RadarDetection::clear_snr() {
  snr_ = 0;
}
inline double RadarDetection::snr() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.snr)
  return snr_;
}
inline void RadarDetection::set_snr(double value) {
  
  snr_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.snr)
}

// double point_target_probability = 9;
inline void RadarDetection::clear_point_target_probability() {
  point_target_probability_ = 0;
}
inline double RadarDetection::point_target_probability() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.point_target_probability)
  return point_target_probability_;
}
inline void RadarDetection::set_point_target_probability(double value) {
  
  point_target_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.point_target_probability)
}

// .osi3.Identifier ambiguity_id = 10;
inline bool RadarDetection::has_ambiguity_id() const {
  return this != internal_default_instance() && ambiguity_id_ != NULL;
}
inline const ::osi3::Identifier& RadarDetection::ambiguity_id() const {
  const ::osi3::Identifier* p = ambiguity_id_;
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.ambiguity_id)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline ::osi3::Identifier* RadarDetection::release_ambiguity_id() {
  // @@protoc_insertion_point(field_release:osi3.RadarDetection.ambiguity_id)
  
  ::osi3::Identifier* temp = ambiguity_id_;
  ambiguity_id_ = NULL;
  return temp;
}
inline ::osi3::Identifier* RadarDetection::mutable_ambiguity_id() {
  
  if (ambiguity_id_ == NULL) {
    ambiguity_id_ = new ::osi3::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetection.ambiguity_id)
  return ambiguity_id_;
}
inline void RadarDetection::set_allocated_ambiguity_id(::osi3::Identifier* ambiguity_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ambiguity_id_);
  }
  if (ambiguity_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ambiguity_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ambiguity_id, submessage_arena);
    }
    
  } else {
    
  }
  ambiguity_id_ = ambiguity_id;
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetection.ambiguity_id)
}

// .osi3.DetectionClassification classification = 11;
inline void RadarDetection::clear_classification() {
  classification_ = 0;
}
inline ::osi3::DetectionClassification RadarDetection::classification() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.classification)
  return static_cast< ::osi3::DetectionClassification >(classification_);
}
inline void RadarDetection::set_classification(::osi3::DetectionClassification value) {
  
  classification_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.classification)
}

// -------------------------------------------------------------------

// LidarDetectionData

// .osi3.SensorDetectionHeader header = 1;
inline bool LidarDetectionData::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void LidarDetectionData::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::osi3::SensorDetectionHeader& LidarDetectionData::header() const {
  const ::osi3::SensorDetectionHeader* p = header_;
  // @@protoc_insertion_point(field_get:osi3.LidarDetectionData.header)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::SensorDetectionHeader*>(
      &::osi3::_SensorDetectionHeader_default_instance_);
}
inline ::osi3::SensorDetectionHeader* LidarDetectionData::release_header() {
  // @@protoc_insertion_point(field_release:osi3.LidarDetectionData.header)
  
  ::osi3::SensorDetectionHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::osi3::SensorDetectionHeader* LidarDetectionData::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::osi3::SensorDetectionHeader;
  }
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetectionData.header)
  return header_;
}
inline void LidarDetectionData::set_allocated_header(::osi3::SensorDetectionHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:osi3.LidarDetectionData.header)
}

// repeated .osi3.LidarDetection detection = 2;
inline int LidarDetectionData::detection_size() const {
  return detection_.size();
}
inline void LidarDetectionData::clear_detection() {
  detection_.Clear();
}
inline const ::osi3::LidarDetection& LidarDetectionData::detection(int index) const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetectionData.detection)
  return detection_.Get(index);
}
inline ::osi3::LidarDetection* LidarDetectionData::mutable_detection(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetectionData.detection)
  return detection_.Mutable(index);
}
inline ::osi3::LidarDetection* LidarDetectionData::add_detection() {
  // @@protoc_insertion_point(field_add:osi3.LidarDetectionData.detection)
  return detection_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::osi3::LidarDetection >*
LidarDetectionData::mutable_detection() {
  // @@protoc_insertion_point(field_mutable_list:osi3.LidarDetectionData.detection)
  return &detection_;
}
inline const ::google::protobuf::RepeatedPtrField< ::osi3::LidarDetection >&
LidarDetectionData::detection() const {
  // @@protoc_insertion_point(field_list:osi3.LidarDetectionData.detection)
  return detection_;
}

// -------------------------------------------------------------------

// LidarDetection

// double existence_probability = 1;
inline void LidarDetection::clear_existence_probability() {
  existence_probability_ = 0;
}
inline double LidarDetection::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.existence_probability)
  return existence_probability_;
}
inline void LidarDetection::set_existence_probability(double value) {
  
  existence_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.existence_probability)
}

// .osi3.Identifier object_id = 2;
inline bool LidarDetection::has_object_id() const {
  return this != internal_default_instance() && object_id_ != NULL;
}
inline const ::osi3::Identifier& LidarDetection::object_id() const {
  const ::osi3::Identifier* p = object_id_;
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.object_id)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline ::osi3::Identifier* LidarDetection::release_object_id() {
  // @@protoc_insertion_point(field_release:osi3.LidarDetection.object_id)
  
  ::osi3::Identifier* temp = object_id_;
  object_id_ = NULL;
  return temp;
}
inline ::osi3::Identifier* LidarDetection::mutable_object_id() {
  
  if (object_id_ == NULL) {
    object_id_ = new ::osi3::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetection.object_id)
  return object_id_;
}
inline void LidarDetection::set_allocated_object_id(::osi3::Identifier* object_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(object_id_);
  }
  if (object_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      object_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, object_id, submessage_arena);
    }
    
  } else {
    
  }
  object_id_ = object_id;
  // @@protoc_insertion_point(field_set_allocated:osi3.LidarDetection.object_id)
}

// .osi3.Spherical3d position = 3;
inline bool LidarDetection::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline const ::osi3::Spherical3d& LidarDetection::position() const {
  const ::osi3::Spherical3d* p = position_;
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.position)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::Spherical3d*>(
      &::osi3::_Spherical3d_default_instance_);
}
inline ::osi3::Spherical3d* LidarDetection::release_position() {
  // @@protoc_insertion_point(field_release:osi3.LidarDetection.position)
  
  ::osi3::Spherical3d* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::osi3::Spherical3d* LidarDetection::mutable_position() {
  
  if (position_ == NULL) {
    position_ = new ::osi3::Spherical3d;
  }
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetection.position)
  return position_;
}
inline void LidarDetection::set_allocated_position(::osi3::Spherical3d* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_);
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:osi3.LidarDetection.position)
}

// .osi3.Spherical3d position_rmse = 4;
inline bool LidarDetection::has_position_rmse() const {
  return this != internal_default_instance() && position_rmse_ != NULL;
}
inline const ::osi3::Spherical3d& LidarDetection::position_rmse() const {
  const ::osi3::Spherical3d* p = position_rmse_;
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.position_rmse)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::Spherical3d*>(
      &::osi3::_Spherical3d_default_instance_);
}
inline ::osi3::Spherical3d* LidarDetection::release_position_rmse() {
  // @@protoc_insertion_point(field_release:osi3.LidarDetection.position_rmse)
  
  ::osi3::Spherical3d* temp = position_rmse_;
  position_rmse_ = NULL;
  return temp;
}
inline ::osi3::Spherical3d* LidarDetection::mutable_position_rmse() {
  
  if (position_rmse_ == NULL) {
    position_rmse_ = new ::osi3::Spherical3d;
  }
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetection.position_rmse)
  return position_rmse_;
}
inline void LidarDetection::set_allocated_position_rmse(::osi3::Spherical3d* position_rmse) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_rmse_);
  }
  if (position_rmse) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position_rmse = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position_rmse, submessage_arena);
    }
    
  } else {
    
  }
  position_rmse_ = position_rmse;
  // @@protoc_insertion_point(field_set_allocated:osi3.LidarDetection.position_rmse)
}

// double height = 5;
inline void LidarDetection::clear_height() {
  height_ = 0;
}
inline double LidarDetection::height() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.height)
  return height_;
}
inline void LidarDetection::set_height(double value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.height)
}

// double height_rmse = 6;
inline void LidarDetection::clear_height_rmse() {
  height_rmse_ = 0;
}
inline double LidarDetection::height_rmse() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.height_rmse)
  return height_rmse_;
}
inline void LidarDetection::set_height_rmse(double value) {
  
  height_rmse_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.height_rmse)
}

// double intensity = 7;
inline void LidarDetection::clear_intensity() {
  intensity_ = 0;
}
inline double LidarDetection::intensity() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.intensity)
  return intensity_;
}
inline void LidarDetection::set_intensity(double value) {
  
  intensity_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.intensity)
}

// double free_space_probability = 8;
inline void LidarDetection::clear_free_space_probability() {
  free_space_probability_ = 0;
}
inline double LidarDetection::free_space_probability() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.free_space_probability)
  return free_space_probability_;
}
inline void LidarDetection::set_free_space_probability(double value) {
  
  free_space_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.free_space_probability)
}

// .osi3.DetectionClassification classification = 9;
inline void LidarDetection::clear_classification() {
  classification_ = 0;
}
inline ::osi3::DetectionClassification LidarDetection::classification() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.classification)
  return static_cast< ::osi3::DetectionClassification >(classification_);
}
inline void LidarDetection::set_classification(::osi3::DetectionClassification value) {
  
  classification_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.classification)
}

// double reflectivity = 10;
inline void LidarDetection::clear_reflectivity() {
  reflectivity_ = 0;
}
inline double LidarDetection::reflectivity() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.reflectivity)
  return reflectivity_;
}
inline void LidarDetection::set_reflectivity(double value) {
  
  reflectivity_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.reflectivity)
}

// -------------------------------------------------------------------

// UltrasonicDetectionSpecificHeader

// double max_range = 1;
inline void UltrasonicDetectionSpecificHeader::clear_max_range() {
  max_range_ = 0;
}
inline double UltrasonicDetectionSpecificHeader::max_range() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetectionSpecificHeader.max_range)
  return max_range_;
}
inline void UltrasonicDetectionSpecificHeader::set_max_range(double value) {
  
  max_range_ = value;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicDetectionSpecificHeader.max_range)
}

// uint32 number_of_valid_indirect_detections = 2;
inline void UltrasonicDetectionSpecificHeader::clear_number_of_valid_indirect_detections() {
  number_of_valid_indirect_detections_ = 0u;
}
inline ::google::protobuf::uint32 UltrasonicDetectionSpecificHeader::number_of_valid_indirect_detections() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetectionSpecificHeader.number_of_valid_indirect_detections)
  return number_of_valid_indirect_detections_;
}
inline void UltrasonicDetectionSpecificHeader::set_number_of_valid_indirect_detections(::google::protobuf::uint32 value) {
  
  number_of_valid_indirect_detections_ = value;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicDetectionSpecificHeader.number_of_valid_indirect_detections)
}

// -------------------------------------------------------------------

// UltrasonicDetectionData

// .osi3.SensorDetectionHeader header = 1;
inline bool UltrasonicDetectionData::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void UltrasonicDetectionData::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::osi3::SensorDetectionHeader& UltrasonicDetectionData::header() const {
  const ::osi3::SensorDetectionHeader* p = header_;
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetectionData.header)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::SensorDetectionHeader*>(
      &::osi3::_SensorDetectionHeader_default_instance_);
}
inline ::osi3::SensorDetectionHeader* UltrasonicDetectionData::release_header() {
  // @@protoc_insertion_point(field_release:osi3.UltrasonicDetectionData.header)
  
  ::osi3::SensorDetectionHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::osi3::SensorDetectionHeader* UltrasonicDetectionData::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::osi3::SensorDetectionHeader;
  }
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicDetectionData.header)
  return header_;
}
inline void UltrasonicDetectionData::set_allocated_header(::osi3::SensorDetectionHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:osi3.UltrasonicDetectionData.header)
}

// .osi3.UltrasonicDetectionSpecificHeader specific_header = 3;
inline bool UltrasonicDetectionData::has_specific_header() const {
  return this != internal_default_instance() && specific_header_ != NULL;
}
inline void UltrasonicDetectionData::clear_specific_header() {
  if (GetArenaNoVirtual() == NULL && specific_header_ != NULL) {
    delete specific_header_;
  }
  specific_header_ = NULL;
}
inline const ::osi3::UltrasonicDetectionSpecificHeader& UltrasonicDetectionData::specific_header() const {
  const ::osi3::UltrasonicDetectionSpecificHeader* p = specific_header_;
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetectionData.specific_header)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::UltrasonicDetectionSpecificHeader*>(
      &::osi3::_UltrasonicDetectionSpecificHeader_default_instance_);
}
inline ::osi3::UltrasonicDetectionSpecificHeader* UltrasonicDetectionData::release_specific_header() {
  // @@protoc_insertion_point(field_release:osi3.UltrasonicDetectionData.specific_header)
  
  ::osi3::UltrasonicDetectionSpecificHeader* temp = specific_header_;
  specific_header_ = NULL;
  return temp;
}
inline ::osi3::UltrasonicDetectionSpecificHeader* UltrasonicDetectionData::mutable_specific_header() {
  
  if (specific_header_ == NULL) {
    specific_header_ = new ::osi3::UltrasonicDetectionSpecificHeader;
  }
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicDetectionData.specific_header)
  return specific_header_;
}
inline void UltrasonicDetectionData::set_allocated_specific_header(::osi3::UltrasonicDetectionSpecificHeader* specific_header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete specific_header_;
  }
  if (specific_header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      specific_header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, specific_header, submessage_arena);
    }
    
  } else {
    
  }
  specific_header_ = specific_header;
  // @@protoc_insertion_point(field_set_allocated:osi3.UltrasonicDetectionData.specific_header)
}

// repeated .osi3.UltrasonicDetection detection = 2;
inline int UltrasonicDetectionData::detection_size() const {
  return detection_.size();
}
inline void UltrasonicDetectionData::clear_detection() {
  detection_.Clear();
}
inline const ::osi3::UltrasonicDetection& UltrasonicDetectionData::detection(int index) const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetectionData.detection)
  return detection_.Get(index);
}
inline ::osi3::UltrasonicDetection* UltrasonicDetectionData::mutable_detection(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicDetectionData.detection)
  return detection_.Mutable(index);
}
inline ::osi3::UltrasonicDetection* UltrasonicDetectionData::add_detection() {
  // @@protoc_insertion_point(field_add:osi3.UltrasonicDetectionData.detection)
  return detection_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::osi3::UltrasonicDetection >*
UltrasonicDetectionData::mutable_detection() {
  // @@protoc_insertion_point(field_mutable_list:osi3.UltrasonicDetectionData.detection)
  return &detection_;
}
inline const ::google::protobuf::RepeatedPtrField< ::osi3::UltrasonicDetection >&
UltrasonicDetectionData::detection() const {
  // @@protoc_insertion_point(field_list:osi3.UltrasonicDetectionData.detection)
  return detection_;
}

// repeated .osi3.UltrasonicIndirectDetection indirect_detection = 4;
inline int UltrasonicDetectionData::indirect_detection_size() const {
  return indirect_detection_.size();
}
inline void UltrasonicDetectionData::clear_indirect_detection() {
  indirect_detection_.Clear();
}
inline const ::osi3::UltrasonicIndirectDetection& UltrasonicDetectionData::indirect_detection(int index) const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetectionData.indirect_detection)
  return indirect_detection_.Get(index);
}
inline ::osi3::UltrasonicIndirectDetection* UltrasonicDetectionData::mutable_indirect_detection(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicDetectionData.indirect_detection)
  return indirect_detection_.Mutable(index);
}
inline ::osi3::UltrasonicIndirectDetection* UltrasonicDetectionData::add_indirect_detection() {
  // @@protoc_insertion_point(field_add:osi3.UltrasonicDetectionData.indirect_detection)
  return indirect_detection_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::osi3::UltrasonicIndirectDetection >*
UltrasonicDetectionData::mutable_indirect_detection() {
  // @@protoc_insertion_point(field_mutable_list:osi3.UltrasonicDetectionData.indirect_detection)
  return &indirect_detection_;
}
inline const ::google::protobuf::RepeatedPtrField< ::osi3::UltrasonicIndirectDetection >&
UltrasonicDetectionData::indirect_detection() const {
  // @@protoc_insertion_point(field_list:osi3.UltrasonicDetectionData.indirect_detection)
  return indirect_detection_;
}

// -------------------------------------------------------------------

// UltrasonicDetection

// double existence_probability = 1;
inline void UltrasonicDetection::clear_existence_probability() {
  existence_probability_ = 0;
}
inline double UltrasonicDetection::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetection.existence_probability)
  return existence_probability_;
}
inline void UltrasonicDetection::set_existence_probability(double value) {
  
  existence_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicDetection.existence_probability)
}

// .osi3.Identifier object_id = 2;
inline bool UltrasonicDetection::has_object_id() const {
  return this != internal_default_instance() && object_id_ != NULL;
}
inline const ::osi3::Identifier& UltrasonicDetection::object_id() const {
  const ::osi3::Identifier* p = object_id_;
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetection.object_id)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline ::osi3::Identifier* UltrasonicDetection::release_object_id() {
  // @@protoc_insertion_point(field_release:osi3.UltrasonicDetection.object_id)
  
  ::osi3::Identifier* temp = object_id_;
  object_id_ = NULL;
  return temp;
}
inline ::osi3::Identifier* UltrasonicDetection::mutable_object_id() {
  
  if (object_id_ == NULL) {
    object_id_ = new ::osi3::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicDetection.object_id)
  return object_id_;
}
inline void UltrasonicDetection::set_allocated_object_id(::osi3::Identifier* object_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(object_id_);
  }
  if (object_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      object_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, object_id, submessage_arena);
    }
    
  } else {
    
  }
  object_id_ = object_id;
  // @@protoc_insertion_point(field_set_allocated:osi3.UltrasonicDetection.object_id)
}

// double distance = 3;
inline void UltrasonicDetection::clear_distance() {
  distance_ = 0;
}
inline double UltrasonicDetection::distance() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetection.distance)
  return distance_;
}
inline void UltrasonicDetection::set_distance(double value) {
  
  distance_ = value;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicDetection.distance)
}

// -------------------------------------------------------------------

// UltrasonicIndirectDetection

// double existence_probability = 1;
inline void UltrasonicIndirectDetection::clear_existence_probability() {
  existence_probability_ = 0;
}
inline double UltrasonicIndirectDetection::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicIndirectDetection.existence_probability)
  return existence_probability_;
}
inline void UltrasonicIndirectDetection::set_existence_probability(double value) {
  
  existence_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicIndirectDetection.existence_probability)
}

// .osi3.Identifier object_id = 2;
inline bool UltrasonicIndirectDetection::has_object_id() const {
  return this != internal_default_instance() && object_id_ != NULL;
}
inline const ::osi3::Identifier& UltrasonicIndirectDetection::object_id() const {
  const ::osi3::Identifier* p = object_id_;
  // @@protoc_insertion_point(field_get:osi3.UltrasonicIndirectDetection.object_id)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline ::osi3::Identifier* UltrasonicIndirectDetection::release_object_id() {
  // @@protoc_insertion_point(field_release:osi3.UltrasonicIndirectDetection.object_id)
  
  ::osi3::Identifier* temp = object_id_;
  object_id_ = NULL;
  return temp;
}
inline ::osi3::Identifier* UltrasonicIndirectDetection::mutable_object_id() {
  
  if (object_id_ == NULL) {
    object_id_ = new ::osi3::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicIndirectDetection.object_id)
  return object_id_;
}
inline void UltrasonicIndirectDetection::set_allocated_object_id(::osi3::Identifier* object_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(object_id_);
  }
  if (object_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      object_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, object_id, submessage_arena);
    }
    
  } else {
    
  }
  object_id_ = object_id;
  // @@protoc_insertion_point(field_set_allocated:osi3.UltrasonicIndirectDetection.object_id)
}

// double ellipsoid_radial = 3;
inline void UltrasonicIndirectDetection::clear_ellipsoid_radial() {
  ellipsoid_radial_ = 0;
}
inline double UltrasonicIndirectDetection::ellipsoid_radial() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicIndirectDetection.ellipsoid_radial)
  return ellipsoid_radial_;
}
inline void UltrasonicIndirectDetection::set_ellipsoid_radial(double value) {
  
  ellipsoid_radial_ = value;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicIndirectDetection.ellipsoid_radial)
}

// double ellipsoid_axial = 4;
inline void UltrasonicIndirectDetection::clear_ellipsoid_axial() {
  ellipsoid_axial_ = 0;
}
inline double UltrasonicIndirectDetection::ellipsoid_axial() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicIndirectDetection.ellipsoid_axial)
  return ellipsoid_axial_;
}
inline void UltrasonicIndirectDetection::set_ellipsoid_axial(double value) {
  
  ellipsoid_axial_ = value;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicIndirectDetection.ellipsoid_axial)
}

// .osi3.Identifier receiver_id = 5;
inline bool UltrasonicIndirectDetection::has_receiver_id() const {
  return this != internal_default_instance() && receiver_id_ != NULL;
}
inline const ::osi3::Identifier& UltrasonicIndirectDetection::receiver_id() const {
  const ::osi3::Identifier* p = receiver_id_;
  // @@protoc_insertion_point(field_get:osi3.UltrasonicIndirectDetection.receiver_id)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline ::osi3::Identifier* UltrasonicIndirectDetection::release_receiver_id() {
  // @@protoc_insertion_point(field_release:osi3.UltrasonicIndirectDetection.receiver_id)
  
  ::osi3::Identifier* temp = receiver_id_;
  receiver_id_ = NULL;
  return temp;
}
inline ::osi3::Identifier* UltrasonicIndirectDetection::mutable_receiver_id() {
  
  if (receiver_id_ == NULL) {
    receiver_id_ = new ::osi3::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicIndirectDetection.receiver_id)
  return receiver_id_;
}
inline void UltrasonicIndirectDetection::set_allocated_receiver_id(::osi3::Identifier* receiver_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(receiver_id_);
  }
  if (receiver_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      receiver_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, receiver_id, submessage_arena);
    }
    
  } else {
    
  }
  receiver_id_ = receiver_id;
  // @@protoc_insertion_point(field_set_allocated:osi3.UltrasonicIndirectDetection.receiver_id)
}

// .osi3.Vector3d receiver_origin = 6;
inline bool UltrasonicIndirectDetection::has_receiver_origin() const {
  return this != internal_default_instance() && receiver_origin_ != NULL;
}
inline const ::osi3::Vector3d& UltrasonicIndirectDetection::receiver_origin() const {
  const ::osi3::Vector3d* p = receiver_origin_;
  // @@protoc_insertion_point(field_get:osi3.UltrasonicIndirectDetection.receiver_origin)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::Vector3d*>(
      &::osi3::_Vector3d_default_instance_);
}
inline ::osi3::Vector3d* UltrasonicIndirectDetection::release_receiver_origin() {
  // @@protoc_insertion_point(field_release:osi3.UltrasonicIndirectDetection.receiver_origin)
  
  ::osi3::Vector3d* temp = receiver_origin_;
  receiver_origin_ = NULL;
  return temp;
}
inline ::osi3::Vector3d* UltrasonicIndirectDetection::mutable_receiver_origin() {
  
  if (receiver_origin_ == NULL) {
    receiver_origin_ = new ::osi3::Vector3d;
  }
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicIndirectDetection.receiver_origin)
  return receiver_origin_;
}
inline void UltrasonicIndirectDetection::set_allocated_receiver_origin(::osi3::Vector3d* receiver_origin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(receiver_origin_);
  }
  if (receiver_origin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      receiver_origin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, receiver_origin, submessage_arena);
    }
    
  } else {
    
  }
  receiver_origin_ = receiver_origin;
  // @@protoc_insertion_point(field_set_allocated:osi3.UltrasonicIndirectDetection.receiver_origin)
}

// -------------------------------------------------------------------

// CameraDetectionSpecificHeader

// uint32 number_of_valid_points = 1;
inline void CameraDetectionSpecificHeader::clear_number_of_valid_points() {
  number_of_valid_points_ = 0u;
}
inline ::google::protobuf::uint32 CameraDetectionSpecificHeader::number_of_valid_points() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetectionSpecificHeader.number_of_valid_points)
  return number_of_valid_points_;
}
inline void CameraDetectionSpecificHeader::set_number_of_valid_points(::google::protobuf::uint32 value) {
  
  number_of_valid_points_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetectionSpecificHeader.number_of_valid_points)
}

// -------------------------------------------------------------------

// CameraDetectionData

// .osi3.SensorDetectionHeader header = 1;
inline bool CameraDetectionData::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CameraDetectionData::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::osi3::SensorDetectionHeader& CameraDetectionData::header() const {
  const ::osi3::SensorDetectionHeader* p = header_;
  // @@protoc_insertion_point(field_get:osi3.CameraDetectionData.header)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::SensorDetectionHeader*>(
      &::osi3::_SensorDetectionHeader_default_instance_);
}
inline ::osi3::SensorDetectionHeader* CameraDetectionData::release_header() {
  // @@protoc_insertion_point(field_release:osi3.CameraDetectionData.header)
  
  ::osi3::SensorDetectionHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::osi3::SensorDetectionHeader* CameraDetectionData::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::osi3::SensorDetectionHeader;
  }
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetectionData.header)
  return header_;
}
inline void CameraDetectionData::set_allocated_header(::osi3::SensorDetectionHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraDetectionData.header)
}

// .osi3.CameraDetectionSpecificHeader specific_header = 3;
inline bool CameraDetectionData::has_specific_header() const {
  return this != internal_default_instance() && specific_header_ != NULL;
}
inline void CameraDetectionData::clear_specific_header() {
  if (GetArenaNoVirtual() == NULL && specific_header_ != NULL) {
    delete specific_header_;
  }
  specific_header_ = NULL;
}
inline const ::osi3::CameraDetectionSpecificHeader& CameraDetectionData::specific_header() const {
  const ::osi3::CameraDetectionSpecificHeader* p = specific_header_;
  // @@protoc_insertion_point(field_get:osi3.CameraDetectionData.specific_header)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::CameraDetectionSpecificHeader*>(
      &::osi3::_CameraDetectionSpecificHeader_default_instance_);
}
inline ::osi3::CameraDetectionSpecificHeader* CameraDetectionData::release_specific_header() {
  // @@protoc_insertion_point(field_release:osi3.CameraDetectionData.specific_header)
  
  ::osi3::CameraDetectionSpecificHeader* temp = specific_header_;
  specific_header_ = NULL;
  return temp;
}
inline ::osi3::CameraDetectionSpecificHeader* CameraDetectionData::mutable_specific_header() {
  
  if (specific_header_ == NULL) {
    specific_header_ = new ::osi3::CameraDetectionSpecificHeader;
  }
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetectionData.specific_header)
  return specific_header_;
}
inline void CameraDetectionData::set_allocated_specific_header(::osi3::CameraDetectionSpecificHeader* specific_header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete specific_header_;
  }
  if (specific_header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      specific_header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, specific_header, submessage_arena);
    }
    
  } else {
    
  }
  specific_header_ = specific_header;
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraDetectionData.specific_header)
}

// repeated .osi3.CameraDetection detection = 2;
inline int CameraDetectionData::detection_size() const {
  return detection_.size();
}
inline void CameraDetectionData::clear_detection() {
  detection_.Clear();
}
inline const ::osi3::CameraDetection& CameraDetectionData::detection(int index) const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetectionData.detection)
  return detection_.Get(index);
}
inline ::osi3::CameraDetection* CameraDetectionData::mutable_detection(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetectionData.detection)
  return detection_.Mutable(index);
}
inline ::osi3::CameraDetection* CameraDetectionData::add_detection() {
  // @@protoc_insertion_point(field_add:osi3.CameraDetectionData.detection)
  return detection_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::osi3::CameraDetection >*
CameraDetectionData::mutable_detection() {
  // @@protoc_insertion_point(field_mutable_list:osi3.CameraDetectionData.detection)
  return &detection_;
}
inline const ::google::protobuf::RepeatedPtrField< ::osi3::CameraDetection >&
CameraDetectionData::detection() const {
  // @@protoc_insertion_point(field_list:osi3.CameraDetectionData.detection)
  return detection_;
}

// repeated .osi3.CameraPoint point = 4;
inline int CameraDetectionData::point_size() const {
  return point_.size();
}
inline void CameraDetectionData::clear_point() {
  point_.Clear();
}
inline const ::osi3::CameraPoint& CameraDetectionData::point(int index) const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetectionData.point)
  return point_.Get(index);
}
inline ::osi3::CameraPoint* CameraDetectionData::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetectionData.point)
  return point_.Mutable(index);
}
inline ::osi3::CameraPoint* CameraDetectionData::add_point() {
  // @@protoc_insertion_point(field_add:osi3.CameraDetectionData.point)
  return point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::osi3::CameraPoint >*
CameraDetectionData::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:osi3.CameraDetectionData.point)
  return &point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::osi3::CameraPoint >&
CameraDetectionData::point() const {
  // @@protoc_insertion_point(field_list:osi3.CameraDetectionData.point)
  return point_;
}

// -------------------------------------------------------------------

// CameraDetection

// double existence_probability = 1;
inline void CameraDetection::clear_existence_probability() {
  existence_probability_ = 0;
}
inline double CameraDetection::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.existence_probability)
  return existence_probability_;
}
inline void CameraDetection::set_existence_probability(double value) {
  
  existence_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.existence_probability)
}

// .osi3.Identifier object_id = 2;
inline bool CameraDetection::has_object_id() const {
  return this != internal_default_instance() && object_id_ != NULL;
}
inline const ::osi3::Identifier& CameraDetection::object_id() const {
  const ::osi3::Identifier* p = object_id_;
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.object_id)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline ::osi3::Identifier* CameraDetection::release_object_id() {
  // @@protoc_insertion_point(field_release:osi3.CameraDetection.object_id)
  
  ::osi3::Identifier* temp = object_id_;
  object_id_ = NULL;
  return temp;
}
inline ::osi3::Identifier* CameraDetection::mutable_object_id() {
  
  if (object_id_ == NULL) {
    object_id_ = new ::osi3::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetection.object_id)
  return object_id_;
}
inline void CameraDetection::set_allocated_object_id(::osi3::Identifier* object_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(object_id_);
  }
  if (object_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      object_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, object_id, submessage_arena);
    }
    
  } else {
    
  }
  object_id_ = object_id;
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraDetection.object_id)
}

// .osi3.Timestamp time_difference = 3;
inline bool CameraDetection::has_time_difference() const {
  return this != internal_default_instance() && time_difference_ != NULL;
}
inline const ::osi3::Timestamp& CameraDetection::time_difference() const {
  const ::osi3::Timestamp* p = time_difference_;
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.time_difference)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::Timestamp*>(
      &::osi3::_Timestamp_default_instance_);
}
inline ::osi3::Timestamp* CameraDetection::release_time_difference() {
  // @@protoc_insertion_point(field_release:osi3.CameraDetection.time_difference)
  
  ::osi3::Timestamp* temp = time_difference_;
  time_difference_ = NULL;
  return temp;
}
inline ::osi3::Timestamp* CameraDetection::mutable_time_difference() {
  
  if (time_difference_ == NULL) {
    time_difference_ = new ::osi3::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetection.time_difference)
  return time_difference_;
}
inline void CameraDetection::set_allocated_time_difference(::osi3::Timestamp* time_difference) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(time_difference_);
  }
  if (time_difference) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      time_difference = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time_difference, submessage_arena);
    }
    
  } else {
    
  }
  time_difference_ = time_difference;
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraDetection.time_difference)
}

// .osi3.CameraDetection.ImageShapeType image_shape_type = 4;
inline void CameraDetection::clear_image_shape_type() {
  image_shape_type_ = 0;
}
inline ::osi3::CameraDetection_ImageShapeType CameraDetection::image_shape_type() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.image_shape_type)
  return static_cast< ::osi3::CameraDetection_ImageShapeType >(image_shape_type_);
}
inline void CameraDetection::set_image_shape_type(::osi3::CameraDetection_ImageShapeType value) {
  
  image_shape_type_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.image_shape_type)
}

// bool shape_classification_background = 5;
inline void CameraDetection::clear_shape_classification_background() {
  shape_classification_background_ = false;
}
inline bool CameraDetection::shape_classification_background() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_background)
  return shape_classification_background_;
}
inline void CameraDetection::set_shape_classification_background(bool value) {
  
  shape_classification_background_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_background)
}

// bool shape_classification_foreground = 6;
inline void CameraDetection::clear_shape_classification_foreground() {
  shape_classification_foreground_ = false;
}
inline bool CameraDetection::shape_classification_foreground() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_foreground)
  return shape_classification_foreground_;
}
inline void CameraDetection::set_shape_classification_foreground(bool value) {
  
  shape_classification_foreground_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_foreground)
}

// bool shape_classification_flat = 7;
inline void CameraDetection::clear_shape_classification_flat() {
  shape_classification_flat_ = false;
}
inline bool CameraDetection::shape_classification_flat() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_flat)
  return shape_classification_flat_;
}
inline void CameraDetection::set_shape_classification_flat(bool value) {
  
  shape_classification_flat_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_flat)
}

// bool shape_classification_upright = 8;
inline void CameraDetection::clear_shape_classification_upright() {
  shape_classification_upright_ = false;
}
inline bool CameraDetection::shape_classification_upright() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_upright)
  return shape_classification_upright_;
}
inline void CameraDetection::set_shape_classification_upright(bool value) {
  
  shape_classification_upright_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_upright)
}

// bool shape_classification_ground = 9;
inline void CameraDetection::clear_shape_classification_ground() {
  shape_classification_ground_ = false;
}
inline bool CameraDetection::shape_classification_ground() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_ground)
  return shape_classification_ground_;
}
inline void CameraDetection::set_shape_classification_ground(bool value) {
  
  shape_classification_ground_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_ground)
}

// bool shape_classification_sky = 10;
inline void CameraDetection::clear_shape_classification_sky() {
  shape_classification_sky_ = false;
}
inline bool CameraDetection::shape_classification_sky() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_sky)
  return shape_classification_sky_;
}
inline void CameraDetection::set_shape_classification_sky(bool value) {
  
  shape_classification_sky_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_sky)
}

// bool shape_classification_vegetation = 11;
inline void CameraDetection::clear_shape_classification_vegetation() {
  shape_classification_vegetation_ = false;
}
inline bool CameraDetection::shape_classification_vegetation() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_vegetation)
  return shape_classification_vegetation_;
}
inline void CameraDetection::set_shape_classification_vegetation(bool value) {
  
  shape_classification_vegetation_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_vegetation)
}

// bool shape_classification_road = 12;
inline void CameraDetection::clear_shape_classification_road() {
  shape_classification_road_ = false;
}
inline bool CameraDetection::shape_classification_road() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_road)
  return shape_classification_road_;
}
inline void CameraDetection::set_shape_classification_road(bool value) {
  
  shape_classification_road_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_road)
}

// bool shape_classification_non_driving_lane = 13;
inline void CameraDetection::clear_shape_classification_non_driving_lane() {
  shape_classification_non_driving_lane_ = false;
}
inline bool CameraDetection::shape_classification_non_driving_lane() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_non_driving_lane)
  return shape_classification_non_driving_lane_;
}
inline void CameraDetection::set_shape_classification_non_driving_lane(bool value) {
  
  shape_classification_non_driving_lane_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_non_driving_lane)
}

// bool shape_classification_non_road = 14;
inline void CameraDetection::clear_shape_classification_non_road() {
  shape_classification_non_road_ = false;
}
inline bool CameraDetection::shape_classification_non_road() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_non_road)
  return shape_classification_non_road_;
}
inline void CameraDetection::set_shape_classification_non_road(bool value) {
  
  shape_classification_non_road_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_non_road)
}

// bool shape_classification_stationary_object = 15;
inline void CameraDetection::clear_shape_classification_stationary_object() {
  shape_classification_stationary_object_ = false;
}
inline bool CameraDetection::shape_classification_stationary_object() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_stationary_object)
  return shape_classification_stationary_object_;
}
inline void CameraDetection::set_shape_classification_stationary_object(bool value) {
  
  shape_classification_stationary_object_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_stationary_object)
}

// bool shape_classification_moving_object = 16;
inline void CameraDetection::clear_shape_classification_moving_object() {
  shape_classification_moving_object_ = false;
}
inline bool CameraDetection::shape_classification_moving_object() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_moving_object)
  return shape_classification_moving_object_;
}
inline void CameraDetection::set_shape_classification_moving_object(bool value) {
  
  shape_classification_moving_object_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_moving_object)
}

// bool shape_classification_landmark = 17;
inline void CameraDetection::clear_shape_classification_landmark() {
  shape_classification_landmark_ = false;
}
inline bool CameraDetection::shape_classification_landmark() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_landmark)
  return shape_classification_landmark_;
}
inline void CameraDetection::set_shape_classification_landmark(bool value) {
  
  shape_classification_landmark_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_landmark)
}

// bool shape_classification_traffic_sign = 18;
inline void CameraDetection::clear_shape_classification_traffic_sign() {
  shape_classification_traffic_sign_ = false;
}
inline bool CameraDetection::shape_classification_traffic_sign() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_traffic_sign)
  return shape_classification_traffic_sign_;
}
inline void CameraDetection::set_shape_classification_traffic_sign(bool value) {
  
  shape_classification_traffic_sign_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_traffic_sign)
}

// bool shape_classification_traffic_light = 19;
inline void CameraDetection::clear_shape_classification_traffic_light() {
  shape_classification_traffic_light_ = false;
}
inline bool CameraDetection::shape_classification_traffic_light() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_traffic_light)
  return shape_classification_traffic_light_;
}
inline void CameraDetection::set_shape_classification_traffic_light(bool value) {
  
  shape_classification_traffic_light_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_traffic_light)
}

// bool shape_classification_road_marking = 20;
inline void CameraDetection::clear_shape_classification_road_marking() {
  shape_classification_road_marking_ = false;
}
inline bool CameraDetection::shape_classification_road_marking() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_road_marking)
  return shape_classification_road_marking_;
}
inline void CameraDetection::set_shape_classification_road_marking(bool value) {
  
  shape_classification_road_marking_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_road_marking)
}

// bool shape_classification_vehicle = 21;
inline void CameraDetection::clear_shape_classification_vehicle() {
  shape_classification_vehicle_ = false;
}
inline bool CameraDetection::shape_classification_vehicle() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_vehicle)
  return shape_classification_vehicle_;
}
inline void CameraDetection::set_shape_classification_vehicle(bool value) {
  
  shape_classification_vehicle_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_vehicle)
}

// bool shape_classification_pedestrian = 22;
inline void CameraDetection::clear_shape_classification_pedestrian() {
  shape_classification_pedestrian_ = false;
}
inline bool CameraDetection::shape_classification_pedestrian() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_pedestrian)
  return shape_classification_pedestrian_;
}
inline void CameraDetection::set_shape_classification_pedestrian(bool value) {
  
  shape_classification_pedestrian_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_pedestrian)
}

// bool shape_classification_animal = 23;
inline void CameraDetection::clear_shape_classification_animal() {
  shape_classification_animal_ = false;
}
inline bool CameraDetection::shape_classification_animal() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_animal)
  return shape_classification_animal_;
}
inline void CameraDetection::set_shape_classification_animal(bool value) {
  
  shape_classification_animal_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_animal)
}

// bool shape_classification_pedestrian_front = 24;
inline void CameraDetection::clear_shape_classification_pedestrian_front() {
  shape_classification_pedestrian_front_ = false;
}
inline bool CameraDetection::shape_classification_pedestrian_front() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_pedestrian_front)
  return shape_classification_pedestrian_front_;
}
inline void CameraDetection::set_shape_classification_pedestrian_front(bool value) {
  
  shape_classification_pedestrian_front_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_pedestrian_front)
}

// bool shape_classification_pedestrian_side = 25;
inline void CameraDetection::clear_shape_classification_pedestrian_side() {
  shape_classification_pedestrian_side_ = false;
}
inline bool CameraDetection::shape_classification_pedestrian_side() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_pedestrian_side)
  return shape_classification_pedestrian_side_;
}
inline void CameraDetection::set_shape_classification_pedestrian_side(bool value) {
  
  shape_classification_pedestrian_side_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_pedestrian_side)
}

// bool shape_classification_pedestrian_rear = 26;
inline void CameraDetection::clear_shape_classification_pedestrian_rear() {
  shape_classification_pedestrian_rear_ = false;
}
inline bool CameraDetection::shape_classification_pedestrian_rear() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_pedestrian_rear)
  return shape_classification_pedestrian_rear_;
}
inline void CameraDetection::set_shape_classification_pedestrian_rear(bool value) {
  
  shape_classification_pedestrian_rear_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_pedestrian_rear)
}

// double shape_classification_probability = 27;
inline void CameraDetection::clear_shape_classification_probability() {
  shape_classification_probability_ = 0;
}
inline double CameraDetection::shape_classification_probability() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_probability)
  return shape_classification_probability_;
}
inline void CameraDetection::set_shape_classification_probability(double value) {
  
  shape_classification_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_probability)
}

// .osi3.CameraDetection.Color color = 28;
inline void CameraDetection::clear_color() {
  color_ = 0;
}
inline ::osi3::CameraDetection_Color CameraDetection::color() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.color)
  return static_cast< ::osi3::CameraDetection_Color >(color_);
}
inline void CameraDetection::set_color(::osi3::CameraDetection_Color value) {
  
  color_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.color)
}

// double color_probability = 29;
inline void CameraDetection::clear_color_probability() {
  color_probability_ = 0;
}
inline double CameraDetection::color_probability() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.color_probability)
  return color_probability_;
}
inline void CameraDetection::set_color_probability(double value) {
  
  color_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.color_probability)
}

// .osi3.Identifier ambiguity_id = 30;
inline bool CameraDetection::has_ambiguity_id() const {
  return this != internal_default_instance() && ambiguity_id_ != NULL;
}
inline const ::osi3::Identifier& CameraDetection::ambiguity_id() const {
  const ::osi3::Identifier* p = ambiguity_id_;
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.ambiguity_id)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline ::osi3::Identifier* CameraDetection::release_ambiguity_id() {
  // @@protoc_insertion_point(field_release:osi3.CameraDetection.ambiguity_id)
  
  ::osi3::Identifier* temp = ambiguity_id_;
  ambiguity_id_ = NULL;
  return temp;
}
inline ::osi3::Identifier* CameraDetection::mutable_ambiguity_id() {
  
  if (ambiguity_id_ == NULL) {
    ambiguity_id_ = new ::osi3::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetection.ambiguity_id)
  return ambiguity_id_;
}
inline void CameraDetection::set_allocated_ambiguity_id(::osi3::Identifier* ambiguity_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ambiguity_id_);
  }
  if (ambiguity_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ambiguity_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ambiguity_id, submessage_arena);
    }
    
  } else {
    
  }
  ambiguity_id_ = ambiguity_id;
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraDetection.ambiguity_id)
}

// uint32 first_point_index = 31;
inline void CameraDetection::clear_first_point_index() {
  first_point_index_ = 0u;
}
inline ::google::protobuf::uint32 CameraDetection::first_point_index() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.first_point_index)
  return first_point_index_;
}
inline void CameraDetection::set_first_point_index(::google::protobuf::uint32 value) {
  
  first_point_index_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.first_point_index)
}

// uint32 number_of_points = 32;
inline void CameraDetection::clear_number_of_points() {
  number_of_points_ = 0u;
}
inline ::google::protobuf::uint32 CameraDetection::number_of_points() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.number_of_points)
  return number_of_points_;
}
inline void CameraDetection::set_number_of_points(::google::protobuf::uint32 value) {
  
  number_of_points_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.number_of_points)
}

// -------------------------------------------------------------------

// CameraPoint

// double existence_probability = 1;
inline void CameraPoint::clear_existence_probability() {
  existence_probability_ = 0;
}
inline double CameraPoint::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.CameraPoint.existence_probability)
  return existence_probability_;
}
inline void CameraPoint::set_existence_probability(double value) {
  
  existence_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraPoint.existence_probability)
}

// .osi3.Spherical3d point = 2;
inline bool CameraPoint::has_point() const {
  return this != internal_default_instance() && point_ != NULL;
}
inline const ::osi3::Spherical3d& CameraPoint::point() const {
  const ::osi3::Spherical3d* p = point_;
  // @@protoc_insertion_point(field_get:osi3.CameraPoint.point)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::Spherical3d*>(
      &::osi3::_Spherical3d_default_instance_);
}
inline ::osi3::Spherical3d* CameraPoint::release_point() {
  // @@protoc_insertion_point(field_release:osi3.CameraPoint.point)
  
  ::osi3::Spherical3d* temp = point_;
  point_ = NULL;
  return temp;
}
inline ::osi3::Spherical3d* CameraPoint::mutable_point() {
  
  if (point_ == NULL) {
    point_ = new ::osi3::Spherical3d;
  }
  // @@protoc_insertion_point(field_mutable:osi3.CameraPoint.point)
  return point_;
}
inline void CameraPoint::set_allocated_point(::osi3::Spherical3d* point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(point_);
  }
  if (point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraPoint.point)
}

// .osi3.Spherical3d point_rmse = 3;
inline bool CameraPoint::has_point_rmse() const {
  return this != internal_default_instance() && point_rmse_ != NULL;
}
inline const ::osi3::Spherical3d& CameraPoint::point_rmse() const {
  const ::osi3::Spherical3d* p = point_rmse_;
  // @@protoc_insertion_point(field_get:osi3.CameraPoint.point_rmse)
  return p != NULL ? *p : *reinterpret_cast<const ::osi3::Spherical3d*>(
      &::osi3::_Spherical3d_default_instance_);
}
inline ::osi3::Spherical3d* CameraPoint::release_point_rmse() {
  // @@protoc_insertion_point(field_release:osi3.CameraPoint.point_rmse)
  
  ::osi3::Spherical3d* temp = point_rmse_;
  point_rmse_ = NULL;
  return temp;
}
inline ::osi3::Spherical3d* CameraPoint::mutable_point_rmse() {
  
  if (point_rmse_ == NULL) {
    point_rmse_ = new ::osi3::Spherical3d;
  }
  // @@protoc_insertion_point(field_mutable:osi3.CameraPoint.point_rmse)
  return point_rmse_;
}
inline void CameraPoint::set_allocated_point_rmse(::osi3::Spherical3d* point_rmse) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(point_rmse_);
  }
  if (point_rmse) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      point_rmse = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, point_rmse, submessage_arena);
    }
    
  } else {
    
  }
  point_rmse_ = point_rmse;
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraPoint.point_rmse)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace osi3

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::osi3::SensorDetectionHeader_DataQualifier> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::osi3::SensorDetectionHeader_DataQualifier>() {
  return ::osi3::SensorDetectionHeader_DataQualifier_descriptor();
}
template <> struct is_proto_enum< ::osi3::SensorDetectionHeader_ExtendedQualifier> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::osi3::SensorDetectionHeader_ExtendedQualifier>() {
  return ::osi3::SensorDetectionHeader_ExtendedQualifier_descriptor();
}
template <> struct is_proto_enum< ::osi3::CameraDetection_Color> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::osi3::CameraDetection_Color>() {
  return ::osi3::CameraDetection_Color_descriptor();
}
template <> struct is_proto_enum< ::osi3::CameraDetection_ImageShapeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::osi3::CameraDetection_ImageShapeType>() {
  return ::osi3::CameraDetection_ImageShapeType_descriptor();
}
template <> struct is_proto_enum< ::osi3::DetectionClassification> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::osi3::DetectionClassification>() {
  return ::osi3::DetectionClassification_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_osi_5ffeaturedata_2eproto__INCLUDED
